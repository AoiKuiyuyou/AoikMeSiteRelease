<!DOCTYPE html>
<html lang="en">

<!-- head -->
<head>
  <!-- Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117972998-1"></script>
  <script>
    var hostname = window.location.hostname;
    if (hostname && hostname !== '127.0.0.1' && hostname !== 'localhost' && hostname !== 'aoik.me.local') {
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117972998-1');
    }
  </script>
  <!-- Google Analytics -->

  <!-- head_meta -->
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- head_meta -->

  <!-- head_title -->
  <title>Python's compiler - from grammar to dfa</title>
  <!-- head_title -->

  <!-- head_links -->
  <link rel="stylesheet" href="/blog/libs_outer/bootstrap/4.0.0/css/bootstrap.min.css">
  <link rel="stylesheet" href="/blog/libs_outer/github-markdown-css/2.10.0/github-markdown.css">
  <link rel="stylesheet" href="/blog/libs_inner/base/base.css">
  <!-- head_links -->

  <!-- head_links2 -->

<link rel="stylesheet" href="/blog/libs_outer/toastr/2.1.3/toastr.min.css">
<link rel="stylesheet" href="/blog/libs_outer/highlight/9.12.0/highlight.min.css">
  <!-- head_links2 -->

  <!-- head_styles -->
  <!-- head_styles -->
</head>
<!-- head -->

<body>
<div id="vue_app">

<!-- header -->
<header>
  <!-- header_inner -->
  <!-- logo -->
  <a class="logo_block" href="/blog"><span class="logo_text">Aoik</span></a>
  <!-- nav -->
  <nav class="nav_block">
    <div class="nav_table">
      <a class="current" href="/blog/posts"><span>Posts</span></a>
      <a class="" href="/blog/reposts"><span>Reposts</span></a>
      <a class="" href="/blog/tags"><span>Tags</span></a>
      <a target="_blank" href="https://github.com/AoiKuiyuyou/Aoik/blob/master/README.md"><span>Github</span></a>
      <a target="_blank" href="http://aoikuiyuyou.github.io/me.html"><span>Resume</span></a>
    </div>
  </nav>
  <!-- header_inner -->
</header>
<!-- header -->

<!-- main -->
<main>
  <!-- main_inner -->
  
  <!-- breadcrumbs -->
  <div class="breadcrumbs_block">
    <a href="/blog">Home</a>
    <span class="sep">&gt;</span>
    <a href="/blog/posts">Posts</a>
    <span class="sep">&gt;</span>
    <a href="">This</a>
  </div>
  <!-- breadcrumbs -->



  <!-- post_info -->
  <div class="post_info_block">
    <div class="tags_block">
    <a class="tag" href="/blog/tags/python">python</a>
    <a class="tag" href="/blog/tags/compiler">compiler</a>
    <a class="tag" href="/blog/tags/parser">parser</a>
    <a class="tag" href="/blog/tags/parser-generator">parser-generator</a>
    <a class="tag" href="/blog/tags/pgen">pgen</a>
    <a class="tag" href="/blog/tags/source-code-study">source-code-study</a>
    <a class="tag" href="/blog/tags/吸星大法强吃源码">吸星大法强吃源码</a>
    </div>
    <div class="fields_block">
      <span class="author">Aoik,</span>
      <span class="create_time">2019.05.06</span>
    </div>
  </div>
  <!-- post_info -->

  <!-- post_content -->
  <!-- `v-pre` aims to skip Vue parsing -->
  <article v-pre class="post_content_block markdown-body">
  <h1 id="python-39-s-compiler-from-grammar-to-dfa">Python&#39;s compiler - from grammar to dfa</h1><p><strong>Python&#39;s compiler series:</strong></p>
<ul>
<li><a href="/blog/posts/python-3.8.0-execution-flow">Python 3.8.0 execution flow</a></li>
<li><a href="/blog/posts/python-compiler-from-grammar-to-dfa">Python&#39;s compiler - from grammar to DFA</a></li>
<li><a href="/blog/posts/python-compiler-the-grammar-file-is-not-ll1-but-the-parser-is">Python&#39;s compiler - the grammar file is not LL(1) but the parser is</a></li>
<li><a href="/blog/posts/python-compiler-from-tokens-to-cst">Python&#39;s compiler - from tokens to CST</a></li>
<li><a href="/blog/posts/python-compiler-from-cst-to-ast">Python&#39;s compiler - from CST to AST</a></li>
<li><a href="/blog/posts/python-compiler-from-ast-to-code-object">Python&#39;s compiler - from AST to code object</a></li>
<li><a href="/blog/posts/python-compiler-from-code-object-to-pyc-file">Python&#39;s compiler - from code object to pyc file</a></li>
</ul>
<p><br>Python&#39;s grammar is LL(1). Instead of using a top-down recursive descent parser, Python uses a DFA-based (Pushdown Automata, more precisely) parser. In Python 3.7, the parser generator <strong>pgen</strong> (<a href="https://github.com/python/cpython/blob/v3.7.0/Parser/pgenmain.c">Parser/pgenmain.c</a>, <a href="https://github.com/python/cpython/blob/v3.7.0/Parser/pgen.c">Parser/pgen.c</a>) is responsible for parsing the grammar file <a href="https://github.com/python/cpython/blob/v3.7.0/Grammar/Grammar">Grammar/Grammar</a> into DFA transition diagram, stored as files <a href="https://github.com/python/cpython/blob/v3.7.0/Include/graminit.h">Include/graminit.h</a> and <a href="https://github.com/python/cpython/blob/v3.7.0/Python/graminit.c">Python/graminit.c</a>. The DFA transition diagram is then used by the DFA-based parser to parse Python code.</p>
<p>To parse the <a href="https://github.com/python/cpython/blob/v3.7.0/Grammar/Grammar">Grammar/Grammar</a> file, <strong>pgen</strong> uses the same DFA-based parser that parses Python code. The only difference is the DFA transition diagram used, which is defined in <a href="https://github.com/python/cpython/blob/v3.7.0/Parser/metagrammar.c#L142">Parser/metagrammar.c</a>. This file is generated using the meta-grammar of the <a href="https://github.com/python/cpython/blob/v3.7.0/Grammar/Grammar">Grammar/Grammar</a> file. Although the meta-grammar file is not present in Python&#39;s reporsitory, by examining functions with initial <code>compile_</code> in <a href="https://github.com/python/cpython/blob/v3.7.0/Parser/pgen.c#L180">Parser/pgen.c</a>, we can infer the meta-grammar as:</p>
<pre><code>MSTART: (NEWLINE | RULE)* ENDMARKER
RULE: NAME &#39;:&#39; RHS NEWLINE
RHS: ALT (&#39;|&#39; ALT)*
ALT: ITEM+
ITEM: &#39;[&#39; RHS &#39;]&#39; | ATOM [&#39;*&#39; | &#39;+&#39;]
ATOM: NAME | STRING | &#39;(&#39; RHS &#39;)&#39;</code></pre><p>In Python 3.7, besides the C version of <strong>pgen</strong>, there is a Python version <a href="https://github.com/python/cpython/tree/v3.7.0/Lib/lib2to3/pgen2">Lib/lib2to3/pgen2</a> that works similarly.</p>
<p>In Python 3.8, the C version of <strong>pgen</strong> has been replaced by a Python version <a href="https://github.com/python/cpython/tree/v3.8.0/Parser/pgen">Parser/pgen</a>, which is slightly modified from Python 3.7&#39;s <a href="https://github.com/python/cpython/tree/v3.7.0/Lib/lib2to3/pgen2">Lib/lib2to3/pgen2</a>.</p>
<p>In Python 3.8, assuming the working directory is Python&#39;s repository directory, the command to generate <a href="https://github.com/python/cpython/blob/v3.8.0/Include/graminit.h">Include/graminit.h</a> and <a href="https://github.com/python/cpython/blob/v3.8.0/Python/graminit.c">Python/graminit.c</a> is:</p>
<pre><code># Linux
export PYTHONPATH=Parser

# Windows
SET PYTHONPATH=Parser

python -m pgen Grammar/Grammar Grammar/Tokens Include/graminit.h Python/graminit.c</code></pre><p><br><strong>pgen</strong>&#39;s calling sequence:</p>
<pre><code>pgen.__main__.main

    pgen.ParserGenerator.__init__

        pgen.ParserGenerator.parse

            pgen.ParserGenerator.make_dfa

            pgen.ParserGenerator.simplify_dfa

        pgen.ParserGenerator.addfirstsets

    pgen.ParserGenerator.make_grammar

        pgen.grammar.Grammar.__init__

    pgen.grammar.Grammar.produce_graminit_h

    pgen.grammar.Grammar.produce_graminit_c</code></pre><p><br><a href="https://github.com/python/cpython/blob/v3.8.0/Parser/pgen/pgen.py">Parser/pgen/pgen.py</a>:</p>
<pre><code>import collections
import tokenize  # from stdlib

from . import grammar, token


class ParserGenerator(object):

    def __init__(self, grammar_file, token_file, stream=None, verbose=False):
        close_stream = None

        if stream is None:
            stream = open(grammar_file)
            close_stream = stream.close

        with open(token_file) as tok_file:
            token_lines = tok_file.readlines()

        # Map terminal symbol name to terminal symbol number.
        self.tokens = dict(token.generate_tokens(token_lines))

        # Map operator text to operator name.
        self.opmap = dict(token.generate_opmap(token_lines))

        # Manually add &lt;&gt; so it does not collide with !=
        self.opmap[&#39;&lt;&gt;&#39;] = &quot;NOTEQUAL&quot;
        self.verbose = verbose
        self.filename = grammar_file
        self.stream = stream
        self.generator = tokenize.generate_tokens(stream.readline)
        self.gettoken() # Initialize lookahead

        # `self.dfas` maps non-terminal symbol name to DFAState objects list.
        self.dfas, self.startsymbol = self.parse()

        if close_stream is not None:
            close_stream()

        # Map non-terminal symbol name to first set of label indexes.
        self.first = {} # map from symbol name to set of tokens

        self.addfirstsets()

    def make_grammar(self):
        c = grammar.Grammar()

        # Get non-terminal symbol names.
        names = list(self.dfas.keys())

        # Put the starting symbol in the front.
        names.remove(self.startsymbol)
        names.insert(0, self.startsymbol)

        # For each non-terminal symbol name.
        for name in names:
            # Allocate symbol number.
            # Non-terminal symbol numbers start with 256.
            i = 256 + len(c.symbol2number)
            # 5IWPC
            # Store the mapping from non-terminal symbol name to symbol number.
            c.symbol2number[name] = i
            # Store the mapping from non-terminal symbol number to symbol name.
            c.number2symbol[i] = name

        # For each non-terminal symbol name.
        for name in names:
            # Allocate label.
            self.make_label(c, name)

            # Get the non-terminal&#39;s DFA.
            # `dfa` is a DFAState objects list
            dfa = self.dfas[name]

            # The the non-terminal&#39;s DFA&#39;s states list.
            # Each state is an arcs list.
            states = []

            # For the non-terminal&#39;s DFA&#39;s each state.
            # `state` is a DFAState object
            for state in dfa:
                # `arcs` is a list of pairs.
                # Each pair&#39;s first item is label index.
                # Each pair&#39;s second item is the next state index.
                arcs = []
                # `label` is the grammar item.
                # `next` is the next `DFAState` object.
                for label, next in sorted(state.arcs.items()):
                    arcs.append((self.make_label(c, label), dfa.index(next)))
                if state.isfinal:
                    arcs.append((0, dfa.index(state)))
                states.append(arcs)

            # 5V13N
            # Store the mapping from non-terminal symbol number minus 256 to
            # its DFA node&#39;s states list.
            c.states.append(states)
            # 3KER2
            # Store the mapping from non-terminal symbol number to its DFA
            # node&#39;s states list and first set.
            c.dfas[c.symbol2number[name]] = (states, self.make_first(c, name))

        # Store the starting symbol number.
        c.start = c.symbol2number[self.startsymbol]

        if self.verbose:
            print(&quot;&quot;)
            print(&quot;Grammar summary&quot;)
            print(&quot;===============&quot;)

            print(&quot;- {n_labels} labels&quot;.format(n_labels=len(c.labels)))
            print(&quot;- {n_dfas} dfas&quot;.format(n_dfas=len(c.dfas)))
            print(&quot;- {n_tokens} tokens&quot;.format(n_tokens=len(c.tokens)))
            print(&quot;- {n_keywords} keywords&quot;.format(n_keywords=len(c.keywords)))
            print(
                &quot;- Start symbol: {start_symbol}&quot;.format(
                    start_symbol=c.number2symbol[c.start]
                )
            )
        return c

    def make_first(self, c, name):
        # Get non-terminal&#39;s first set in terms of grammar items.
        rawfirst = self.first[name]

        # The non-terminal&#39;s first set in terms of label indexes.
        first = set()

        # For each grammar item.
        for label in sorted(rawfirst):
            # Get the grammar item&#39;s label index.
            ilabel = self.make_label(c, label)

            ##assert ilabel not in first # XXX failed on &lt;&gt; ... !=
            first.add(ilabel)

        return first

    def make_label(self, c, label):
        # XXX Maybe this should be a method on a subclass of converter?

        # `label` is a grammar item.
        # `make_label` adds a label tuple (symbol number, keyword text) to
        # `c.labels` for each distinct grammar item. The index into `c.labels`
        # represents the grammar item in the generated grammar structure&#39;s
        # arcs.

        # Get label index.
        ilabel = len(c.labels)
        # If the first character is alpha, then `label` is either a
        # non-terminal symbol name or a named token (e.g. NAME, NUMBER,
        # STRING).
        if label[0].isalpha():
            # Either a symbol name or a named token
            # A non-terminal symbol name.
            if label in c.symbol2number:
                # A symbol name (a non-terminal)
                # If label has been allocated.
                if label in c.symbol2label:
                    # Return the label index.
                    return c.symbol2label[label]
                else:
                    # 6SFOH
                    # Add a tuple (symbol number, None).
                    c.labels.append((c.symbol2number[label], None))
                    # 3UWQN
                    # Store the mapping from symbol number to label index.
                    c.symbol2label[label] = ilabel
                    # Return the label index.
                    return ilabel
            # A named token.
            else:
                # A named token (NAME, NUMBER, STRING)
                # Get terminal symbol number.
                itoken = self.tokens.get(label, None)
                assert isinstance(itoken, int), label
                assert itoken in self.tokens.values(), label
                # If label has been allocated.
                if itoken in c.tokens:
                    return c.tokens[itoken]
                else:
                    # 6SFOH
                    # Add a label tuple (terminal symbol number, None).
                    c.labels.append((itoken, None))

                    # 6FHBO
                    # Store the mapping from terminal symbol number to label
                    # index.
                    c.tokens[itoken] = ilabel
                    return ilabel
        # If the first character is not alpha, then `label` is either a keyword
        # or an operator.
        else:
            # Either a keyword or an operator
            assert label[0] in (&#39;&quot;&#39;, &quot;&#39;&quot;), label
            value = eval(label)
            # If it is a keyword.
            if value[0].isalpha():
                # A keyword
                # If label has been allocated.
                if value in c.keywords:
                    # Return the label index.
                    return c.keywords[value]
                else:
                    # 6SFOH
                    # Add a label tuple (terminal symbol NAME&#39;s number, keyword
                    # text).
                    c.labels.append((self.tokens[&quot;NAME&quot;], value))

                    # 7W5Z2
                    # Store the mapping from keyword text to label index.
                    c.keywords[value] = ilabel

                    # Return the label index.
                    return ilabel
            # If it is an operator.
            else:
                # An operator (any non-numeric token)
                # Get terminal symbol name.
                tok_name = self.opmap[value] # Fails if unknown token

                # Get terminal symbol number.
                itoken = self.tokens[tok_name]

                # If label has been allocated.
                if itoken in c.tokens:
                    # Return the label index.
                    return c.tokens[itoken]
                else:
                    # 6SFOH
                    # Add a label tuple (terminal symbol number, None).
                    c.labels.append((itoken, None))

                    # 6FHBO
                    # Store the mapping from terminal symbol number to label
                    # index.
                    c.tokens[itoken] = ilabel

                    # Return the label index.
                    return ilabel

    def addfirstsets(self):
        names = list(self.dfas.keys())
        for name in names:
            if name not in self.first:
                self.calcfirst(name)

            if self.verbose:
                print(&quot;First set for {dfa_name}&quot;.format(dfa_name=name))
                for item in self.first[name]:
                    print(&quot;    - {terminal}&quot;.format(terminal=item))

    def calcfirst(self, name):
        dfa = self.dfas[name]
        self.first[name] = None # dummy to detect left recursion
        # Get the DFA&#39;s first state.
        # The first state&#39;s arcs&#39; labels belong to the first set.
        state = dfa[0]
        totalset = set()
        overlapcheck = {}
        for label, next in state.arcs.items():
            # If the label is non-terminal name.
            if label in self.dfas:
                if label in self.first:
                    fset = self.first[label]
                    if fset is None:
                        raise ValueError(&quot;recursion for rule %r&quot; % name)
                else:
                    # Calculate the non-terminal&#39;s first set.
                    self.calcfirst(label)
                    fset = self.first[label]
                totalset.update(fset)
                overlapcheck[label] = fset
            # If the label is terminal.
            else:
                totalset.add(label)
                overlapcheck[label] = {label}
        inverse = {}
        for label, itsfirst in overlapcheck.items():
            for symbol in itsfirst:
                if symbol in inverse:
                    raise ValueError(&quot;rule %s is ambiguous; %s is in the&quot;
                                     &quot; first sets of %s as well as %s&quot; %
                                     (name, symbol, label, inverse[symbol]))
                inverse[symbol] = label
        self.first[name] = totalset

    def parse(self):
        # Grammar:
        # MSTART: (NEWLINE | RULE)* ENDMARKER
        # RULE: NAME &#39;:&#39; RHS NEWLINE
        # RHS: ALT (&#39;|&#39; ALT)*
        # ALT: ITEM+
        # ITEM: &#39;[&#39; RHS &#39;]&#39; | ATOM [&#39;*&#39; | &#39;+&#39;]
        # ATOM: NAME | STRING | &#39;(&#39; RHS &#39;)&#39;

        # Map non-terminal symbol name to DFAState objects list.
        dfas = collections.OrderedDict()

        # The starting symbol name.
        startsymbol = None

        # MSTART: (NEWLINE | RULE)* ENDMARKER
        while self.type != tokenize.ENDMARKER:
            while self.type == tokenize.NEWLINE:
                self.gettoken()
            # RULE: NAME &#39;:&#39; RHS NEWLINE
            name = self.expect(tokenize.NAME)
            if self.verbose:
                print(&quot;Processing rule {dfa_name}&quot;.format(dfa_name=name))
            self.expect(tokenize.OP, &quot;:&quot;)
            a, z = self.parse_rhs()
            self.expect(tokenize.NEWLINE)
            if self.verbose:
                self.dump_nfa(name, a, z)
            dfa = self.make_dfa(a, z)
            if self.verbose:
                self.dump_dfa(name, dfa)
            self.simplify_dfa(dfa)
            dfas[name] = dfa
            if startsymbol is None:
                startsymbol = name
        return dfas, startsymbol

    def make_dfa(self, start, finish):
        # To turn an NFA into a DFA, we define the states of the DFA
        # to correspond to *sets* of states of the NFA.  Then do some
        # state reduction.  Let&#39;s represent sets as dicts with 1 for
        # values.
        assert isinstance(start, NFAState)
        assert isinstance(finish, NFAState)
        def closure(state):
            base = set()
            addclosure(state, base)
            return base
        def addclosure(state, base):
            assert isinstance(state, NFAState)
            if state in base:
                return
            base.add(state)
            for label, next in state.arcs:
                if label is None:
                    addclosure(next, base)
        # DFAState objects list.
        # Each DFAState contains a set of NFAState objects and their epsilon closure NFAState objects.
        states = [DFAState(closure(start), finish)]
        for state in states: # NB states grows while we&#39;re iterating
            # Map label to next state&#39;s NFAState objects set.
            arcs = {}
            # Code below does non-epsilon transition from the current DFAState&#39;s NFAState objects set to the next states.
            # For current DFAState&#39;s each NFAState.
            for nfastate in state.nfaset:
                # For the NFAState&#39;s each arc.
                for label, next in nfastate.arcs:
                    # If the arc is non-epsilon.
                    if label is not None:
                        # Add the next NFAState&#39;s closure NFAState objects to the set for the label.
                        addclosure(next, arcs.setdefault(label, set()))
            # For each label and the next state&#39;s NFAState objects set.
            for label, nfaset in sorted(arcs.items()):
                # For each existing DFAState.
                for st in states:
                    # If the next state&#39;s NFAState objects set equals that of an existing DFAState.
                    if st.nfaset == nfaset:
                        # Found the DFAState for the next state.
                        break
                # If the next state&#39;s NFAState objects set not equals that of any existing DFAState.
                else:
                    # Create a new DFAState for the next state.
                    st = DFAState(nfaset, finish)
                    states.append(st)
                # Add a DFA arc from the current DFAState to the next DFAState.
                state.addarc(st, label)
        return states # List of DFAState instances; first one is start

    def dump_nfa(self, name, start, finish):
        print(&quot;Dump of NFA for&quot;, name)
        todo = [start]
        for i, state in enumerate(todo):
            print(&quot;  State&quot;, i, state is finish and &quot;(final)&quot; or &quot;&quot;)
            for label, next in state.arcs:
                if next in todo:
                    j = todo.index(next)
                else:
                    j = len(todo)
                    todo.append(next)
                if label is None:
                    print(&quot;    -&gt; %d&quot; % j)
                else:
                    print(&quot;    %s -&gt; %d&quot; % (label, j))

    def dump_dfa(self, name, dfa):
        print(&quot;Dump of DFA for&quot;, name)
        for i, state in enumerate(dfa):
            print(&quot;  State&quot;, i, state.isfinal and &quot;(final)&quot; or &quot;&quot;)
            for label, next in sorted(state.arcs.items()):
                print(&quot;    %s -&gt; %d&quot; % (label, dfa.index(next)))

    def simplify_dfa(self, dfa):
        # This is not theoretically optimal, but works well enough.
        # Algorithm: repeatedly look for two states that have the same
        # set of arcs (same labels pointing to the same nodes) and
        # unify them, until things stop changing.

        # dfa is a list of DFAState instances
        changes = True
        while changes:
            changes = False
            for i, state_i in enumerate(dfa):
                for j in range(i+1, len(dfa)):
                    state_j = dfa[j]
                    if state_i == state_j:
                        #print &quot;  unify&quot;, i, j
                        del dfa[j]
                        for state in dfa:
                            state.unifystate(state_j, state_i)
                        changes = True
                        break

    def parse_rhs(self):
        # RHS: ALT (&#39;|&#39; ALT)*
        a, z = self.parse_alt()
        if self.value != &quot;|&quot;:
            return a, z
        else:
            # Head.
            aa = NFAState()
            # Tail.
            zz = NFAState()
            # One branch.
            aa.addarc(a)
            z.addarc(zz)
            while self.value == &quot;|&quot;:
                self.gettoken()
                a, z = self.parse_alt()
                # One branch.
                aa.addarc(a)
                z.addarc(zz)
            return aa, zz

    def parse_alt(self):
        # ALT: ITEM+
        a, b = self.parse_item()
        while (self.value in (&quot;(&quot;, &quot;[&quot;) or
               self.type in (tokenize.NAME, tokenize.STRING)):
            c, d = self.parse_item()
            # Chain old tail to new item&#39;s head.
            b.addarc(c)
            # Use new item&#39;s tail as new tail.
            b = d
        return a, b

    def parse_item(self):
        # ITEM: &#39;[&#39; RHS &#39;]&#39; | ATOM [&#39;+&#39; | &#39;*&#39;]
        if self.value == &quot;[&quot;:
            self.gettoken()
            a, z = self.parse_rhs()
            self.expect(tokenize.OP, &quot;]&quot;)
            # Head goes directly to tail because `[]` means optional.
            a.addarc(z)
            return a, z
        else:
            a, z = self.parse_atom()
            value = self.value
            if value not in (&quot;+&quot;, &quot;*&quot;):
                return a, z
            self.gettoken()
            # `z` can go to `a` to repeat.
            z.addarc(a)
            if value == &quot;+&quot;:
                # For `+`, `a` needs to go to `z` once.
                return a, z
            else:
                # For `*`, `a` needs not to go to `z` once.
                return a, a

    def parse_atom(self):
        # ATOM: &#39;(&#39; RHS &#39;)&#39; | NAME | STRING
        if self.value == &quot;(&quot;:
            self.gettoken()
            a, z = self.parse_rhs()
            self.expect(tokenize.OP, &quot;)&quot;)
            return a, z
        elif self.type in (tokenize.NAME, tokenize.STRING):
            a = NFAState()
            z = NFAState()
            a.addarc(z, self.value)
            self.gettoken()
            return a, z
        else:
            self.raise_error(&quot;expected (...) or NAME or STRING, got %s/%s&quot;,
                             self.type, self.value)

    def expect(self, type, value=None):
        if self.type != type or (value is not None and self.value != value):
            self.raise_error(&quot;expected %s/%s, got %s/%s&quot;,
                             type, value, self.type, self.value)
        value = self.value
        self.gettoken()
        return value

    def gettoken(self):
        tup = next(self.generator)
        while tup[0] in (tokenize.COMMENT, tokenize.NL):
            tup = next(self.generator)
        self.type, self.value, self.begin, self.end, self.line = tup
        # print(getattr(tokenize, &#39;tok_name&#39;)[self.type], repr(self.value))

    def raise_error(self, msg, *args):
        if args:
            try:
                msg = msg % args
            except Exception:
                msg = &quot; &quot;.join([msg] + list(map(str, args)))
        raise SyntaxError(msg, (self.filename, self.end[0],
                                self.end[1], self.line))

class NFAState(object):

    def __init__(self):
        self.arcs = [] # list of (label, NFAState) pairs

    def addarc(self, next, label=None):
        assert label is None or isinstance(label, str)
        assert isinstance(next, NFAState)
        self.arcs.append((label, next))

class DFAState(object):

    def __init__(self, nfaset, final):
        assert isinstance(nfaset, set)
        assert isinstance(next(iter(nfaset)), NFAState)
        assert isinstance(final, NFAState)
        self.nfaset = nfaset
        self.isfinal = final in nfaset
        self.arcs = {} # map from label to DFAState

    def addarc(self, next, label):
        assert isinstance(label, str)
        assert label not in self.arcs
        assert isinstance(next, DFAState)
        self.arcs[label] = next

    def unifystate(self, old, new):
        for label, next in self.arcs.items():
            if next is old:
                self.arcs[label] = new

    def __eq__(self, other):
        # Equality test -- ignore the nfaset instance variable
        assert isinstance(other, DFAState)
        if self.isfinal != other.isfinal:
            return False
        # Can&#39;t just return self.arcs == other.arcs, because that
        # would invoke this method recursively, with cycles...
        if len(self.arcs) != len(other.arcs):
            return False
        for label, next in self.arcs.items():
            if next is not other.arcs.get(label):
                return False
        return True

    __hash__ = None # For Py3 compatibility.</code></pre><p><br><a href="https://github.com/python/cpython/blob/v3.8.0/Parser/pgen/grammar.py">Parser/pgen/grammar.py</a>:</p>
<pre><code>import collections


class Grammar:
    &quot;&quot;&quot;Pgen parsing tables class.

    The instance variables are as follows:

    symbol2number -- a dict mapping symbol names to numbers.  Symbol
                     numbers are always 256 or higher, to distinguish
                     them from token numbers, which are between 0 and
                     255 (inclusive).

    number2symbol -- a dict mapping numbers to symbol names;
                     these two are each other&#39;s inverse.

    states        -- a list of DFAs, where each DFA is a list of
                     states, each state is a list of arcs, and each
                     arc is a (i, j) pair where i is a label and j is
                     a state number.  The DFA number is the index into
                     this list.  (This name is slightly confusing.)
                     Final states are represented by a special arc of
                     the form (0, j) where j is its own state number.

    dfas          -- a dict mapping symbol numbers to (DFA, first)
                     pairs, where DFA is an item from the states list
                     above, and first is a set of tokens that can
                     begin this grammar rule.

    labels        -- a list of (x, y) pairs where x is either a token
                     number or a symbol number, and y is either None
                     or a string; the strings are keywords.  The label
                     number is the index in this list; label numbers
                     are used to mark state transitions (arcs) in the
                     DFAs.

    start         -- the number of the grammar&#39;s start symbol.

    keywords      -- a dict mapping keyword strings to arc labels.

    tokens        -- a dict mapping token numbers to arc labels.

    &quot;&quot;&quot;

    def __init__(self):
        # Map non-terminal symbol name to number.
        # Numbers start with 256.
        # Filled at 5IWPC.
        self.symbol2number = collections.OrderedDict()

        # Map non-terminal symbol number to symbol name.
        # Filled at 5IWPC.
        self.number2symbol = collections.OrderedDict()

        # Map non-terminal symbol number minus 256 to its DFA node&#39;s states
        # list.
        # Each state is an arcs list.
        # Each arc is a tuple (label_index, next_state_index),
        # Filled at 5V13N.
        self.states = []

        # Map non-terminal symbol number to its DFA node&#39;s states list and
        # first set.
        # Filled at 3KER2.
        self.dfas = collections.OrderedDict()

        # A list of pairs.
        # Each pair&#39;s first item is token index or non-terminal symbol index.
        # Each pair&#39;s second item is keyword text for NAME token.
        # The list&#39;s item indexes are label indexes, i.e. numeric references
        # to tokens and symbols.
        # Filled at 6SFOH.
        self.labels = [(0, &quot;EMPTY&quot;)]

        # Map keyword text to label index.
        # Filled at 7W5Z2.
        self.keywords = collections.OrderedDict()

        # Map terminal symbol number to label index.
        # Token indexes are determined by the order in the `tokens` file.
        # Label indexes are into `self.labels`.
        # Filled at 6FHBO.
        self.tokens = collections.OrderedDict()

        # Map non-terminal symbol name to label index.
        # Label indexes are into `self.labels`.
        # Filled at 3UWQN.
        self.symbol2label = collections.OrderedDict()

        # The starting symbol number.
        self.start = 256

    def produce_graminit_h(self, writer):
        writer(&quot;/* Generated by Parser/pgen */\n\n&quot;)
        for number, symbol in self.number2symbol.items():
            writer(&quot;#define {} {}\n&quot;.format(symbol, number))

    def produce_graminit_c(self, writer):
        writer(&quot;/* Generated by Parser/pgen */\n\n&quot;)

        writer(&#39;#include &quot;grammar.h&quot;\n&#39;)
        writer(&quot;grammar _PyParser_Grammar;\n&quot;)

        self.print_dfas(writer)
        self.print_labels(writer)

        writer(&quot;grammar _PyParser_Grammar = {\n&quot;)
        writer(&quot;    {n_dfas},\n&quot;.format(n_dfas=len(self.dfas)))
        writer(&quot;    dfas,\n&quot;)
        writer(&quot;    {{{n_labels}, labels}},\n&quot;.format(n_labels=len(self.labels)))
        writer(&quot;    {start_number}\n&quot;.format(start_number=self.start))
        writer(&quot;};\n&quot;)

    def print_labels(self, writer):
        writer(
            &quot;static const label labels[{n_labels}] = {{\n&quot;.format(n_labels=len(self.labels))
        )
        for label, name in self.labels:
            label_name = &#39;&quot;{}&quot;&#39;.format(name) if name is not None else 0
            writer(
                &#39;    {{{label}, {label_name}}},\n&#39;.format(
                    label=label, label_name=label_name
                )
            )
        writer(&quot;};\n&quot;)

    def print_dfas(self, writer):
        self.print_states(writer)
        writer(&quot;static const dfa dfas[{}] = {{\n&quot;.format(len(self.dfas)))
        for dfaindex, dfa_elem in enumerate(self.dfas.items()):
            symbol, (dfa, first_sets) = dfa_elem
            writer(
                &#39;    {{{dfa_symbol}, &quot;{symbol_name}&quot;, &#39;.format(
                    dfa_symbol=symbol, symbol_name=self.number2symbol[symbol]
                )
                + &quot;{n_states}, states_{dfa_index},\n&quot;.format(
                    n_states=len(dfa), dfa_index=dfaindex
                )
                + &#39;     &quot;&#39;
            )

            bitset = bytearray((len(self.labels) &gt;&gt; 3) + 1)
            for token in first_sets:
                # `token &gt;&gt; 3` is the byte index containing the bit.
                # `1 &lt;&lt; (token &amp; 7)` is the byte value with the bit set on.
                bitset[token &gt;&gt; 3] |= 1 &lt;&lt; (token &amp; 7)
            for byte in bitset:
                writer(&quot;\\%03o&quot; % (byte &amp; 0xFF))
            writer(&#39;&quot;},\n&#39;)
        writer(&quot;};\n&quot;)

    def print_states(self, write):
        for dfaindex, dfa in enumerate(self.states):
            self.print_arcs(write, dfaindex, dfa)
            write(
                &quot;static state states_{dfa_index}[{n_states}] = {{\n&quot;.format(
                    dfa_index=dfaindex, n_states=len(dfa)
                )
            )
            for stateindex, state in enumerate(dfa):
                narcs = len(state)
                write(
                    &quot;    {{{n_arcs}, arcs_{dfa_index}_{state_index}}},\n&quot;.format(
                        n_arcs=narcs, dfa_index=dfaindex, state_index=stateindex
                    )
                )
            write(&quot;};\n&quot;)

    def print_arcs(self, write, dfaindex, states):
        for stateindex, state in enumerate(states):
            narcs = len(state)
            write(
                &quot;static const arc arcs_{dfa_index}_{state_index}[{n_arcs}] = {{\n&quot;.format(
                    dfa_index=dfaindex, state_index=stateindex, n_arcs=narcs
                )
            )
            for a, b in state:
                write(
                    &quot;    {{{from_label}, {to_state}}},\n&quot;.format(
                        from_label=a, to_state=b
                    )
                )
            write(&quot;};\n&quot;)</code></pre><p><br>The <a href="https://github.com/python/cpython/blob/v3.8.0/Parser/pgen/pgen.py#L168">pgen.ParserGenerator.parse</a> function parses the <a href="https://github.com/python/cpython/blob/v3.8.0/Grammar/Grammar">Grammar/Grammar</a> file. It is top-down recursive descent, calling <a href="https://github.com/python/cpython/blob/v3.8.0/Parser/pgen/pgen.py#L273">parse_rhs</a>, <a href="https://github.com/python/cpython/blob/v3.8.0/Parser/pgen/pgen.py#L290">parse_alt</a>, <a href="https://github.com/python/cpython/blob/v3.8.0/Parser/pgen/pgen.py#L300">parse_item</a>, and <a href="https://github.com/python/cpython/blob/v3.8.0/Parser/pgen/pgen.py#L320">parse_atom</a> along the way. Each of the <code>parse_</code> functions creates a starting and an ending <code>NFAState</code> objects, and these <code>NFAState</code> objects get chained together to form a NFA transition diagram. For each rule in the grammar, <a href="https://github.com/python/cpython/blob/v3.8.0/Parser/pgen/pgen.py#L193">pgen.ParserGenerator.make_dfa</a> is called with the rule&#39;s starting and ending <code>NFAState</code> objects to convert the NFA transition diagram to a DFA transition diagram. Then <a href="https://github.com/python/cpython/blob/v3.8.0/Parser/pgen/pgen.py#L252">pgen.ParserGenerator.simplify_dfa</a> is called to combine equivalent <code>DFAState</code> objects. Then <a href="https://github.com/python/cpython/blob/v3.8.0/Parser/pgen/pgen.py#L127">pgen.ParserGenerator.addfirstsets</a> is called to calculate first set of non-terminal symbols. Then <a href="https://github.com/python/cpython/blob/v3.8.0/Parser/pgen/pgen.py#L31">pgen.ParserGenerator.make_grammar</a> is called. It uses <a href="https://github.com/python/cpython/blob/v3.8.0/Parser/pgen/pgen.py#L80">pgen.ParserGenerator.make_label</a> to assign numeric indexes to terminal tokens and non-terminal symbols because the resulting data structure representing the DFA transition diagram uses numeric indexes. Finally <a href="https://github.com/python/cpython/blob/v3.8.0/Parser/pgen/grammar.py#L56">pgen.grammar.Grammar.produce_graminit_h</a> and <a href="https://github.com/python/cpython/blob/v3.8.0/Parser/pgen/grammar.py#L61">pgen.grammar.Grammar.produce_graminit_c</a> are called to generate files <a href="https://github.com/python/cpython/blob/v3.8.0/Include/graminit.h">Include/graminit.h</a> and <a href="https://github.com/python/cpython/blob/v3.8.0/Python/graminit.c">Python/graminit.c</a>.</p>
<p><br>Check out Guido&#39;s post about <a href="http://python-history.blogspot.com/2018/05/the-origins-of-pgen.html">the origins of pgen</a>.</p>

  </article>
  <!-- post_content -->

  <div class="prev_next_posts_block">
    <div>
      <span class="prev_post_prompt">Previous Post: </span><a class="prev_post_link" href="/blog/posts/flask-log-request-response">Flask log request response</a><span class="prev_post_date">(2019.04.09)</span>
    </div>
    <div>
      <span class="next_post_prompt">Next Post: </span><a class="next_post_link" href="/blog/posts/python-compiler-the-grammar-file-is-not-ll1-but-the-parser-is">Python's compiler - the grammar file is not LL(1) but the parser is</a><span class="next_post_date">(2019.05.12)</span>
    </div>
  </div>

  <!-- Special syntax below is for Vue rendering on the client side -->
  <div v-cloak id="post_comments_block" class="post_comments_block">
    <p class="title">Comments:</p>
    <div class="write_comment_block">
      <div class="comment_info_block">
        <input v-model="commenter_name" class="commenter_name" placeholder="Your name"></input>
        <div class="replyto_block">
          <span>Reply to:</span>
          <select v-model="replyto_comment_id">
             <!-- `0` is a special value meaning no replyto -->
             <option disabled value="0"></option>
             <option v-for="comment_id in comment_ids" :value="comment_id">{{comment_id}}</option>
          </select>
        </div>
      </div>
      <textarea v-model="comment_content" class="comment_content" placeholder="Comment"></textarea>
      <div><input v-on:click="comment_submit_button_on_click" class="submit_button" type="button" value="Submit"></input></div>
    </div>
    <ul>
        <li v-for="comment_info in comment_infos" v-bind:class="comment_info.is_admin ? 'is_admin' : ''">
            <a v-bind:id="'comment-' + comment_info.comment_id"
              v-bind:href="'#comment-' + comment_info.comment_id" class="comment_id">{{comment_info.comment_id}}</a>
            <div class="comment_content">{{comment_info.comment_content}}</div>
            <div class="comment_info">
              <span class="commenter_name">{{comment_info.commenter_name}}</span>
              <span class="create_time">{{comment_info.create_time}}</span>
              <template v-if="comment_info.replyto_comment_id > 0">
              <span>to <a v-bind:href="'#comment-' + comment_info.replyto_comment_id">comment-{{comment_info.replyto_comment_id}}</a></span>
              </template>
              <a v-bind:data-comment-id="comment_info.comment_id" v-on:click="comment_reply_button_on_click" class="reply_button" href="#post_comments_block">Reply to this</a>
            </div>
        </li>
    </ul>
  </div>
  

  <!-- post_toc -->
  <div id="post_toc_block" class="post_toc_block is_hidden">
    <a v-on:click="post_toc_hide_link_on_click" data-shown-text="Hide" data-hidden-text="TOC" class="hide_link" href="javascript:void(0)">TOC</a>
    <span class="title">Contents</span>
  </div>
  <!-- post_toc -->

  <!-- back_to_top -->
  <div id="back_to_top_block" class="back_to_top_block is_hidden">
    <a v-on:click="back_to_top_button_on_click">
      <div class="arrow_shape">
        <div class="arrow_head"></div>
        <div class="arrow_body"></div>
      </div>
    </a>
  </div>
  <!-- back_to_top -->

  <div id="post_id" style="display: none;">30</div>
  <!-- main_inner -->
</main>
<!-- main -->

<!-- back_to_top -->

<!-- footer -->
<footer>
  <!-- footer_inner -->
  <span>This blog is powered by my own project <a href="https://github.com/AoiKuiyuyou/AoikSeldomStaticSite">AoikSeldomStaticSite</a>.</span>
  <!-- footer_inner -->
</footer>
<!-- footer -->

<!-- bottom_scripts -->

<script type="text/javascript" src="/blog/libs_outer/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="/blog/libs_outer/vue/2.5.16/vue.min.js"></script>
<script type="text/javascript" src="/blog/libs_outer/toastr/2.1.3/toastr.min.js"></script>
<script type="text/javascript" src="/blog/libs_outer/highlight/9.12.0/highlight.min.js"></script>
<script type="text/javascript" src="/blog/libs_inner/base/post.js"></script>
<!-- bottom_scripts -->

</div>
<!-- vue_app -->

</body>
</html>
