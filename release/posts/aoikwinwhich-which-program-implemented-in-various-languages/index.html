<!DOCTYPE html>
<html lang="en">

<!-- head -->
<head>
  <!-- Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-117972998-1"></script>
  <script>
    var hostname = window.location.hostname;
    if (hostname && hostname !== '127.0.0.1' && hostname !== 'localhost' && hostname !== 'aoik.me.local') {
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-117972998-1');
    }
  </script>
  <!-- Google Analytics -->

  <!-- head_meta -->
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- head_meta -->

  <!-- head_title -->
  <title>AoikWinWhich - which program implemented in various languages</title>
  <!-- head_title -->

  <!-- head_links -->
  <link rel="stylesheet" href="/blog/libs_outer/bootstrap/4.0.0/css/bootstrap.min.css">
  <link rel="stylesheet" href="/blog/libs_outer/github-markdown-css/2.10.0/github-markdown.css">
  <link rel="stylesheet" href="/blog/libs_inner/base/base.css">
  <!-- head_links -->

  <!-- head_links2 -->

<link rel="stylesheet" href="/blog/libs_outer/toastr/2.1.3/toastr.min.css">
<link rel="stylesheet" href="/blog/libs_outer/highlight/9.12.0/highlight.min.css">
  <!-- head_links2 -->

  <!-- head_styles -->
  <!-- head_styles -->
</head>
<!-- head -->

<body>
<div id="vue_app">

<!-- header -->
<header>
  <!-- header_inner -->
  <!-- logo -->
  <a class="logo_block" href="/blog"><span class="logo_text">Aoik</span></a>
  <!-- nav -->
  <nav class="nav_block">
    <div class="nav_table">
      <a class="current" href="/blog/posts"><span>Posts</span></a>
      <a class="" href="/blog/reposts"><span>Reposts</span></a>
      <a class="" href="/blog/tags"><span>Tags</span></a>
      <a target="_blank" href="https://github.com/AoiKuiyuyou/Aoik/blob/master/README.md"><span>Github</span></a>
      <a target="_blank" href="http://aoikuiyuyou.github.io/me.html"><span>Resume</span></a>
    </div>
  </nav>
  <!-- header_inner -->
</header>
<!-- header -->

<!-- main -->
<main>
  <!-- main_inner -->
  
  <!-- breadcrumbs -->
  <div class="breadcrumbs_block">
    <a href="/blog">Home</a>
    <span class="sep">&gt;</span>
    <a href="/blog/posts">Posts</a>
    <span class="sep">&gt;</span>
    <a href="">This</a>
  </div>
  <!-- breadcrumbs -->



  <!-- post_info -->
  <div class="post_info_block">
    <div class="tags_block">
    <a class="tag" href="/blog/tags/which">which</a>
    <a class="tag" href="/blog/tags/bash">bash</a>
    <a class="tag" href="/blog/tags/batch">batch</a>
    <a class="tag" href="/blog/tags/c">c</a>
    <a class="tag" href="/blog/tags/ceylon">ceylon</a>
    <a class="tag" href="/blog/tags/clojure">clojure</a>
    <a class="tag" href="/blog/tags/coffeescript">coffeescript</a>
    <a class="tag" href="/blog/tags/cpp">cpp</a>
    <a class="tag" href="/blog/tags/cpp-cli">cpp-cli</a>
    <a class="tag" href="/blog/tags/csharp">csharp</a>
    <a class="tag" href="/blog/tags/d">d</a>
    <a class="tag" href="/blog/tags/dart">dart</a>
    <a class="tag" href="/blog/tags/eiffel">eiffel</a>
    <a class="tag" href="/blog/tags/erlang">erlang</a>
    <a class="tag" href="/blog/tags/fsharp">fsharp</a>
    <a class="tag" href="/blog/tags/go">go</a>
    <a class="tag" href="/blog/tags/groovy">groovy</a>
    <a class="tag" href="/blog/tags/haskell">haskell</a>
    <a class="tag" href="/blog/tags/hy">hy</a>
    <a class="tag" href="/blog/tags/java">java</a>
    <a class="tag" href="/blog/tags/javascript">javascript</a>
    <a class="tag" href="/blog/tags/julia">julia</a>
    <a class="tag" href="/blog/tags/kotlin">kotlin</a>
    <a class="tag" href="/blog/tags/lua">lua</a>
    <a class="tag" href="/blog/tags/ocaml">ocaml</a>
    <a class="tag" href="/blog/tags/pascal">pascal</a>
    <a class="tag" href="/blog/tags/perl">perl</a>
    <a class="tag" href="/blog/tags/php">php</a>
    <a class="tag" href="/blog/tags/python">python</a>
    <a class="tag" href="/blog/tags/ruby">ruby</a>
    <a class="tag" href="/blog/tags/rust">rust</a>
    <a class="tag" href="/blog/tags/scala">scala</a>
    <a class="tag" href="/blog/tags/scheme">scheme</a>
    <a class="tag" href="/blog/tags/tcl">tcl</a>
    <a class="tag" href="/blog/tags/vb.net">vb.net</a>
    <a class="tag" href="/blog/tags/xtend">xtend</a>
    </div>
    <div class="fields_block">
      <span class="author">Aoik,</span>
      <span class="create_time">2018.04.22</span>
    </div>
  </div>
  <!-- post_info -->

  <!-- post_content -->
  <!-- `v-pre` aims to skip Vue parsing -->
  <article v-pre class="post_content_block markdown-body">
  <h1 id="aoikwinwhich-which-program-implemented-in-various-languages">AoikWinWhich - which program implemented in various languages</h1><h2 id="aoikwinwhich-bash"><a class="anchor" href="#aoikwinwhich-bash"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Bash</h2><pre><code>#!/usr/bin/env bash

function strings_has {
    #/
    local item=&quot;$1&quot;

    #/
    local elem

    for elem in &quot;${@:2}&quot;;
    do
        [[ &quot;$elem&quot; == &quot;$item&quot; ]] &amp;&amp; return 0
    done

    #/
    return 1
}

function strings_uniq {
    #/ $1 is name of result variable to set on return
    local resvar=&quot;$1&quot;

    #/ $2 upwards are array items
    shift

    local item_s=(&quot;${@}&quot;)

    #/
    local item_new_s=()

    for item in &quot;${item_s[@]}&quot;
    do
        strings_has &quot;$item&quot; &quot;${item_new_s[@]}&quot; || item_new_s+=(&quot;$item&quot;)
    done

    #/
    eval $resvar=&#39;( &quot;${item_new_s[@]}&quot; )&#39;
}

function strings_trim()
{
    #/ $1 is name of result variable to set on return
    local resvar=&quot;$1&quot;

    #/ $2 upwards are array items
    shift

    local item_s=(&quot;${@}&quot;)

    #/
    local item_new_s=()

    local item_new

    for item in &quot;${item_s[@]}&quot;
    do
        if [[ &quot;$item&quot; =~ ^[[:space:]]*([^[:space:]].*[^[:space:]])[[:space:]]*$ ]]
        then
            item_new=&quot;${BASH_REMATCH[1]}&quot;
        else
            item_new=&quot;$item&quot;
        fi
        item_new_s+=(&quot;$item_new&quot;)
    done

    #/
    eval $resvar=&#39;( &quot;${item_new_s[@]}&quot; )&#39;
}

function strings_unempty()
{
    #/ $1 is name of result variable to set on return
    local resvar=&quot;$1&quot;

    #/ $2 upwards are array items
    shift

    local item_s=(&quot;${@}&quot;)

    #/
    local item_new_s=()

    for item in &quot;${item_s[@]}&quot;
    do
        if [ -n &quot;$item&quot; ]; then
            item_new_s+=(&quot;$item&quot;)
        fi
    done

    #/
    eval $resvar=&#39;( &quot;${item_new_s[@]}&quot; )&#39;
}

function strings_lower()
{
    #/ $1 is name of result variable to set on return
    local resvar=&quot;$1&quot;

    #/ $2 upwards are array items
    shift

    local item_s=(&quot;${@}&quot;)

    #/
    local item_new_s=()

    for item in &quot;${item_s[@]}&quot;
    do
        item_new_s+=(&quot;${item,,}&quot;)
    done

    #/
    eval $resvar=&#39;( &quot;${item_new_s[@]}&quot; )&#39;
}

function strings_anyisendof {
    #/
    local item=&quot;$1&quot;

    #/
    local elem

    for elem in &quot;${@:2}&quot;;
    do
        [[ &quot;$item&quot; == *&quot;$elem&quot; ]] &amp;&amp; return 0
    done

    #/
    return 1
}

function find_executable {
    #/ $1 is name of result variable to set on return
    local resvar=&quot;$1&quot;

    #/
    local prog=&quot;$2&quot;

    #/ 6qhHTHF
    #/ split into a list of extensions
    OIFS=&quot;$IFS&quot;
    IFS=&#39;;&#39;
    [ -z &quot;$PATHEXT&quot; ] &amp;&amp; ext_s=() || ext_s=( $PATHEXT )
    IFS=&quot;$OIFS&quot;

    #/ 2pGJrMW
    #/ strip
    strings_trim ext_s &quot;${ext_s[@]}&quot;

    #/ 2gqeHHl
    #/ remove empty
    strings_unempty ext_s &quot;${ext_s[@]}&quot;

    #/ 2zdGM8W
    #/ convert to lowercase
    strings_lower ext_s &quot;${ext_s[@]}&quot;

    #/ 2fT8aRB
    #/ uniquify
    strings_uniq ext_s &quot;${ext_s[@]}&quot;

    #/ 6mPI0lg
    OIFS=&quot;$IFS&quot;
    IFS=&#39;:&#39;
    ## In Cygwin, |;| in PATH is converted to |:|.
    [ -z &quot;$PATH&quot; ] &amp;&amp; dir_path_s=() || dir_path_s=( $PATH )
    IFS=&quot;$OIFS&quot;

    #/ 5rT49zI
    #/ insert empty dir path to the beginning
    ##
    ## Empty dir handles the case that |prog| is a path, either relative or
    ##  absolute. See code 7rO7NIN.
    dir_path_s=( &#39;&#39; &quot;${dir_path_s[@]}&quot;)

    #/ 2klTv20
    #/ uniquify
    strings_uniq dir_path_s &quot;${dir_path_s[@]}&quot;

    #/ 6bFwhbv
    exe_path_s=()

    for dir_path in &quot;${dir_path_s[@]}&quot;; do
        #/ 7rO7NIN
        #/ synthesize a path with the dir and prog
        if [ &quot;$dir_path&quot; == &#39;&#39; ]; then
            path=&quot;$prog&quot;
        else
            path=&quot;$dir_path/$prog&quot;
        fi

        #/ 6kZa5cq
        ## assume the path has extension, check if it is an executable
        if strings_anyisendof &quot;$path&quot; &quot;${ext_s[@]}&quot;; then
            if [ -f &quot;$path&quot; ]; then
                exe_path_s=( &quot;${exe_path_s[@]}&quot; &quot;$path&quot; )
            fi
        fi

        #/ 2sJhhEV
        ## assume the path has no extension
        for ext in &quot;${ext_s[@]}&quot;; do
            #/ 6k9X6GP
            #/ synthesize a new path with the path and the executable extension
            path_plus_ext=&quot;$path$ext&quot;

            #/ 6kabzQg
            #/ check if it is an executable
            if [ -f &quot;$path_plus_ext&quot; ]; then
                exe_path_s=( &quot;${exe_path_s[@]}&quot; &quot;$path_plus_ext&quot; )
            fi
        done
    done

    #/ 8swW6Av
    #/ uniquify
    strings_uniq exe_path_s &quot;${exe_path_s[@]}&quot;

    #/
    eval $resvar=&#39;( &quot;${exe_path_s[@]}&quot; )&#39;
}

function main {
    #/ 9mlJlKg
    if [ &quot;$#&quot; != &quot;1&quot; ]; then
        #/ 7rOUXFo
        #/ print program usage
        echo &#39;Usage: aoikwinwhich PROG&#39;
        echo &#39;&#39;
        echo &#39;#/ PROG can be either name or path&#39;
        echo &#39;aoikwinwhich notepad.exe&#39;
        echo &#39;aoikwinwhich C:\Windows\notepad.exe&#39;
        echo &#39;&#39;
        echo &#39;#/ PROG can be either absolute or relative&#39;
        echo &#39;aoikwinwhich C:\Windows\notepad.exe&#39;
        echo &#39;aoikwinwhich Windows\notepad.exe&#39;
        echo &#39;&#39;
        echo &#39;#/ PROG can be either with or without extension&#39;
        echo &#39;aoikwinwhich notepad.exe&#39;
        echo &#39;aoikwinwhich notepad&#39;
        echo &#39;aoikwinwhich C:\Windows\notepad.exe&#39;
        echo &#39;aoikwinwhich C:\Windows\notepad&#39;

        #/ 3nqHnP7
        return
    fi

    #/ 9m5B08H
    #/ get name or path of a program from cmd arg
    prog=&quot;$1&quot;

    #/ 8ulvPXM
    #/ find executables
    find_executable path_s &quot;$prog&quot;

    #/ 5fWrcaF
    #/ has found none, exit
    if [ &quot;${#path_s[@]}&quot; == &quot;0&quot; ]; then
        #/ 3uswpx0
        return
    fi

    #/ 9xPCWuS
    #/ has found some, output
    printf &quot;%s\n&quot; &quot;${path_s[@]}&quot;

    #/ 4s1yY1b
    return
}

main &quot;$@&quot;</code></pre><h2 id="aoikwinwhich-batch"><a class="anchor" href="#aoikwinwhich-batch"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Batch</h2><pre><code>@echo off
setlocal EnableDelayedExpansion

::/
call :main %*
exit /B

::/ define a |strIndex| func
::# Copied from: http://stackoverflow.com/a/22928259
::--BEG
:strIndex string substring [instance]
    REM Using adaptation of strLen function found at http://www.dostips.com/DtCodeCmdLib.php#Function.strLen

    SETLOCAL ENABLEDELAYEDEXPANSION
    SETLOCAL ENABLEEXTENSIONS
    IF &quot;%~2&quot; EQU &quot;&quot; SET Index=-1 &amp; GOTO strIndex_end
    IF &quot;%~3&quot; EQU &quot;&quot; (SET Instance=1) ELSE (SET Instance=%~3)
    SET Index=-1
    SET String=%~1

    SET &quot;str=A%~1&quot;
    SET &quot;String_Length=0&quot;
    FOR /L %%A IN (12,-1,0) DO (
        SET /a &quot;String_Length|=1&lt;&lt;%%A&quot;
        FOR %%B IN (!String_Length!) DO IF &quot;!str:~%%B,1!&quot;==&quot;&quot; SET /a &quot;String_Length&amp;=~1&lt;&lt;%%A&quot;
    )
    SET &quot;sub=A%~2&quot;
    SET &quot;Substring_Length=0&quot;
    FOR /L %%A IN (12,-1,0) DO (
        SET /a &quot;Substring_Length|=1&lt;&lt;%%A&quot;
        FOR %%B IN (!Substring_Length!) DO IF &quot;!sub:~%%B,1!&quot;==&quot;&quot; SET /a &quot;Substring_Length&amp;=~1&lt;&lt;%%A&quot;
    )

    IF %Substring_Length% GTR %String_Length% GOTO strIndex_end

    SET /A Searches=%String_Length%-%Substring_Length%
    IF %Instance% GTR 0 (
        FOR /L %%n IN (0,1,%Searches%) DO (
            CALL SET StringSegment=%%String:~%%n,!Substring_Length!%%

            IF &quot;%~2&quot; EQU &quot;!StringSegment!&quot; SET /A Instance-=1
            IF !Instance! EQU 0 SET Index=%%n &amp; GOTO strIndex_end
    )) ELSE (
        FOR /L %%n IN (%Searches%,-1,0) DO (
            CALL SET StringSegment=%%String:~%%n,!Substring_Length!%%

            IF &quot;%~2&quot; EQU &quot;!StringSegment!&quot; SET /A Instance+=1
            IF !Instance! EQU 0 SET Index=%%n &amp; GOTO strIndex_end
    ))

:strIndex_end
    EXIT /B %Index%
::--END

:items_exists
REM %~1: items&#39; array-like variable name prefix
REM %~2: items&#39; count
REM %~3: item to check if it exists in the items
    ::/
    setlocal

    ::/
    set items_vnp=%~1

    ::/
    set items_cnt=%~2

    ::/
    set item=%~3

    ::/
    set /A items_imax=items_cnt-1

    for /L %%m in (0,1,!items_imax!) do (
        call set &quot;cur_item=%%!items_vnp![%%m]%%&quot;

        if &quot;!item!&quot; == &quot;!cur_item!&quot; (
            exit /B 0
        )
    )

    exit /B 1
goto:eof

:exts_anyisendof
REM %~1: exts&#39; array-like variable name prefix
REM %~2: exts&#39; count
REM %~3: path to check if it ends with one of the exts
    ::/
    setlocal

    ::/
    set exts_vnp=%~1

    ::/
    set exts_cnt=%~2

    ::/
    set path=%~3

    ::/
    set /A exts_imax=exts_cnt-1

    for /L %%x in (0,1,!exts_imax!) do (
        call set &quot;ext=%%!exts_vnp![%%x]%%&quot;

        ::/ check if the path ends with one of the exts
        REM :: Tried using |findstr| but very slow.
        REM --BEG
        REM set regex=.*\!ext!
        REM echo.!path!|&gt;nul findstr /I /rx &quot;!regex!&quot;
        REM --END

        call :strIndex &quot;!path!&quot; &quot;.&quot; -1

        set ext_dot_idx=!errorlevel!

        if ext_dot_idx neq -1 (
            call set path_ext=%%path:~!ext_dot_idx!%%

            if /I &quot;!path_ext!&quot;==&quot;!ext!&quot; (
                exit /B 0
            )
        )
    )

    exit /B 1
goto:eof

::/
:find_executable
REM %~1: prog name or path
    ::/
    setlocal

    ::/
    set prog=%~1

    ::/ 6qhHTHF
    ::/ split into a list of extensions
    set i=0

    for %%e in (&quot;%PATHEXT:;=&quot;;&quot;%&quot;) do (
        ::/
        set _ext=%%~e

        ::/ 2gqeHHl
        REM:: remove empty
        if not &quot;!_ext!&quot; == &quot;&quot; (
            call set &quot;ext_s[%%i%%]=!_ext!&quot;
            set /A i=i+1
        )
    )

    set /A exts_cnt=i

    set /A ext_imax=exts_cnt-1

    ::/ 6bFwhbv
    set i=0
    ::: loop index

    set res_path_i=0
    ::: result index

    for %%x in (&quot;&quot; &quot;%PATH:;=&quot;;&quot;%&quot;) do (
        ::/ 7rO7NIN
        REM :: synthesize a path with the dir and prog
        if &quot;%%~x&quot; == &quot;&quot; (
            if &quot;!i!&quot; == &quot;0&quot; (
                set path=%prog%
            ) else (
                ::/ ignore empty dir unless it&#39;s the first
                set path=
            )
        ) else (
            set path=%%~x\%prog%
        )

        ::/
        if not &quot;!path!&quot; == &quot;&quot; (
            ::/ 6kZa5cq
            REM :: assume the path has extension, check if it is an executable
            if exist &quot;!path!&quot; if not exist &quot;!path!\&quot; (
                ::/ check if the path ends with one of the exts
                call :exts_anyisendof &quot;ext_s&quot; &quot;!exts_cnt!&quot; &quot;!path!&quot;
                ::: Y
                if &quot;!errorlevel!&quot; == &quot;0&quot; (
                    ::/ check if the path exists in result
                    call :items_exists &quot;res_path_s&quot; &quot;!res_path_i!&quot; &quot;!path!&quot;
                    ::: N
                    if not &quot;!errorlevel!&quot; == &quot;0&quot; (
                        ::/ add to res_path_s
                        call set &quot;res_path_s[!res_path_i!]=!path!&quot;

                        ::/
                        set /A res_path_i=res_path_i+1
                    )
                )
            )

            ::/ 2sJhhEV
            REM :: assume the path has no extension
            for /L %%k in (0,1,%ext_imax%) do (
                ::/ 6k9X6GP
                REM :: synthesize a new path with the path and the executable extension
                set ext=!ext_s[%%k]!

                set path_plus_ext=!path!!ext!

                ::/ 6kabzQg
                REM :: check if it is an executable
                if exist &quot;!path_plus_ext!&quot; if not exist &quot;!path_plus_ext!\&quot; (
                    ::/ check if the path exists in result
                    call :items_exists &quot;res_path_s&quot; &quot;!res_path_i!&quot; &quot;!path_plus_ext!&quot;
                    ::: N
                    if not &quot;!errorlevel!&quot; == &quot;0&quot; (
                        ::/ add to res_path_s
                        call set &quot;res_path_s[!res_path_i!]=!path_plus_ext!&quot;

                        ::/
                        set /A res_path_i=res_path_i+1
                    )
                )
            )
        )

        ::/
        set /A i=i+1
    )

    ::/ 5fWrcaF
    ::/ has found none, exit
    if %res_path_i% equ 0 (
        ::/ 3uswpx0
        exit /B
    )

    ::/ 9xPCWuS
    ::/ has found some, output
    set /A res_path_imax=res_path_i-1

    for /L %%n in (0,1,%res_path_imax%) do (
        echo !res_path_s[%%n]!
    )
goto:eof

:main
    ::/
    setlocal

    ::/ 9mlJlKg
    ::/ check if one cmd arg is given
    set args_len=0
    for %%x in (%*) do set /A args_len+=1

    :: N
    if not &quot;%args_len%&quot; == &quot;1&quot; (
        ::/ 7rOUXFo
        ::/ print program usage
        echo.Usage: aoikwinwhich PROG
        echo.
        echo.#/ PROG can be either name or path
        echo.aoikwinwhich notepad.exe
        echo.aoikwinwhich C:\Windows\notepad.exe
        echo.
        echo.#/ PROG can be either absolute or relative
        echo.aoikwinwhich C:\Windows\notepad.exe
        echo.aoikwinwhich Windows\notepad.exe
        echo.
        echo.#/ PROG can be either with or without extension
        echo.aoikwinwhich notepad.exe
        echo.aoikwinwhich notepad
        echo.aoikwinwhich C:\Windows\notepad.exe
        echo.aoikwinwhich C:\Windows\notepad

        ::/ 3nqHnP7
        exit /B
    )

    ::/ 9m5B08H
    ::/ get name or path of a program from cmd arg
    set prog=%~1

    ::/ 8ulvPXM
    ::/ find executables
    call :find_executable &quot;!prog!&quot;

    ::/ 4s1yY1b
    exit /B

goto:eof</code></pre><h2 id="aoikwinwhich-c"><a class="anchor" href="#aoikwinwhich-c"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-C</h2><pre><code>//
#include &quot;stdafx.h&quot;
#include &lt;windows.h&gt;
#include &lt;Shlwapi.h&gt;
#pragma comment(lib, &quot;Shlwapi.lib&quot;)

//
typedef char const * String;

//
typedef struct StringNode
{
    String str;
    struct StringNode* next;
} StringNode;

//
typedef struct StringList
{
    StringNode* head;
    StringNode* end;
    size_t count;
} StringList;

//
StringNode* stringnode_create(String str) {
    //
    StringNode* str_node = (StringNode*)malloc(sizeof(StringNode));

    //
    str_node-&gt;str = str;

    str_node-&gt;next = NULL;

    //
    return str_node;
}

//
StringList* stringlist_create() {
    //
    StringList* str_list = (StringList*)malloc(sizeof(StringList));

    //
    str_list-&gt;head = NULL;
    str_list-&gt;end = NULL;
    str_list-&gt;count = 0;

    //
    return str_list;
}

//
void stringlist_add_head(StringList* str_list, String str) {
    //
    StringNode* item = stringnode_create(str);

    //if strlist-&gt;end
    if (str_list-&gt;count == 0) {
        //
        assert(!str_list-&gt;head);

        assert(!str_list-&gt;end);

        //
        str_list-&gt;head = item;

        str_list-&gt;end = item;

        // new end clears &quot;next&quot;
        str_list-&gt;end-&gt;next = NULL;
    }
    else {
        //
        assert(str_list-&gt;head);

        assert(str_list-&gt;end);

        // new head links to old head
        item-&gt;next = str_list-&gt;head;

        // set new head
        str_list-&gt;head = item;
    }

    //
    str_list-&gt;count += 1;
}

//
void stringlist_add_end(StringList* str_list, String str) {
    //
    StringNode* item = stringnode_create(str);

    //if strlist-&gt;end
    if (str_list-&gt;count == 0) {
        //
        assert(!str_list-&gt;head);

        assert(!str_list-&gt;end);

        //
        str_list-&gt;head = item;

        str_list-&gt;end = item;

        // new end clears &quot;next&quot;
        str_list-&gt;end-&gt;next = NULL;
    }
    else {
        //
        assert(str_list-&gt;head);

        assert(str_list-&gt;end);

        // old end links to new end
        str_list-&gt;end-&gt;next = item;

        // set new end
        str_list-&gt;end = item;

        // new end clears &quot;next&quot;
        str_list-&gt;end-&gt;next = NULL;
    }

    //
    str_list-&gt;count += 1;
}

//
BOOL stringlist_contains(StringList* str_list, String str) {
    //
    StringNode* node = str_list-&gt;head;

    while (node) {
        // If two strings are equal
        if (!strcmp(node-&gt;str, str)) {
            return TRUE;
        };

        //
        node = node-&gt;next;
    }

    return FALSE;
}

//
void stringlist_uniq(
    StringList* res_list, // Result
    StringList* str_list)
{
    //
    StringNode* node = str_list-&gt;head;

    while (node) {
        //
        if (!stringlist_contains(res_list, node-&gt;str)) {
            // String &quot;node-&gt;str&quot; is changed ownership
            stringlist_add_end(res_list, node-&gt;str);

            // Clear old pointer
            node-&gt;str = NULL;
        };

        //
        node = node-&gt;next;
    }
}

//
void stringlist_del(StringList* str_list) {
    //
    StringNode* node = str_list-&gt;head;

    while (node) {
        //
        StringNode* next = node-&gt;next;

        //
        if (node-&gt;str) {
            //
            free((void*)node-&gt;str);

            //
            node-&gt;str = NULL;
        }

        node-&gt;next = NULL;

        free(node);

        //
        node = next;
    }

    //
    str_list-&gt;head = NULL;

    str_list-&gt;end = NULL;

    str_list-&gt;count = 0;

    //
    free(str_list);
}

//
void stringlist_del_v2(
    StringList** str_list_pp // &quot;pp&quot; means pointer pointer
    ) {
    //
    assert(str_list_pp);

    assert(*str_list_pp);

    //
    stringlist_del(*str_list_pp);

    // Set the &quot;StringList pointer&quot; to NULL, in order to avoid address violation.
    *str_list_pp = NULL;
}

//
char* string_copy_new(const char* str) {
    //
    size_t str_bytes_cnt = sizeof(char) * (strlen(str) + 1);

    //
    char* str_copy = (char *)malloc(str_bytes_cnt);

    //
    memcpy(str_copy, str, str_bytes_cnt);

    str_copy[str_bytes_cnt - 1] = &#39;\0&#39;;

    //
    return str_copy;
}

//
void string_split(StringList* str_s, String str, char sep) {
    //
    char sep_str[2];

    sep_str[0] = sep;
    sep_str[1] = &#39;\0&#39;;

    //
    size_t str_len = strlen(str);

    size_t start = 0;

    while (TRUE) {
        //
        String substr_start = str + start;

        // 2a1XF8a
        // Can be 0 when the first char is the sep char.
        size_t substr_cnt = strcspn(substr_start, sep_str);

        // &quot;+ 1&quot; for null terminator.
        //
        // &quot;substr_cnt&quot; at 2a1XF8a being 0 is well handled.
        size_t substr_byte_cnt = sizeof(char) * (substr_cnt + 1);

        //
        char* substr = malloc(substr_byte_cnt);

        // &quot;substr_cnt&quot; at 2a1XF8a being 0 is well handled.
        memcpy(substr, substr_start, substr_cnt);

        substr[substr_cnt] = &#39;\0&#39;;

        //
        stringlist_add_end(str_s, substr);

        // &quot;+ 1&quot; for skipping the sep char that stops &quot;strcspn&quot; at 2a1XF8a.
        //
        // If what stops &quot;strcspn&quot; at 2a1XF8a is null char, then &quot;start&quot; should
        // equal (str_len + 1). This is well handled at 7fkzkrk.
        start += (substr_cnt + 1);

        // 7fkzkrk
        if (start &gt; str_len) {
            //
            assert(start == (str_len + 1));

            //
            break;
        }
        // This is the case when the last char is the sep char
        else if (start == str_len) {
            //
            assert(str[str_len - 1] == sep);

            // Allocate an empty string
            char* empty_str = malloc(sizeof(char));

            empty_str[0] = &#39;\0&#39;;

            // Add the last empty string.
            // E.g. string_split(&quot;a|b|&quot;, &#39;|&#39;) -&gt; [&quot;a&quot;, &quot;b&quot;, &quot;&quot;]
            stringlist_add_end(str_s, empty_str);

            //
            break;
        }
    }
}

//
void string_strip(char *str) {
    //
    char *end;

    // Remove heading spaces.
    //
    // Null char is well handled by &quot;isspace&quot;.
    while (isspace(*str)) {
        str++;
    }

    //
    if (*str == &#39;\0&#39;) {
        return;
    }

    // Remove ending spaces
    end = str + strlen(str) - 1;

    while (end &gt; str &amp;&amp; isspace(*end)) {
        end--;
    }

    // Set null
    *(end + 1) = &#39;\0&#39;;
}

//
void string_tolower(char* str) {
    //
    size_t i = 0;

    for (i = 0; str[i]; i++) {
        str[i] = tolower(str[i]);
    }
}

//
char* string_concat_new(const char* str, const char* end) {
    //
    int str_len = strlen(str);

    int end_len = strlen(end);

    //
    size_t bytes_cnt = sizeof(char) * (str_len + end_len + 1);

    //
    char* str_new = (char *)malloc(bytes_cnt);

    //
    memcpy(str_new, str, str_len);

    memcpy(str_new + str_len, end, end_len);

    // Set last bytes to NUL
    str_new[str_len + end_len] = &#39;\0&#39;;

    //
    return str_new;
}

//
BOOL string_endswith(const char* str, const char* end) {
    //
    int str_len = strlen(str);

    int end_len = strlen(end);

    //
    return
        // &quot;str&quot; is not shorter then &quot;end&quot;
        (str_len &gt;= end_len) &amp;&amp;
        // Two strings&#39; ends are equal
        (!strcmp(str + str_len - end_len, end));
}

//
BOOL prog_has_ext_in(String prog, StringList* ext_s) {
    //
    StringNode* node = ext_s-&gt;head;

    while (node) {
        // If two strings are equal
        if (string_endswith(prog, node-&gt;str)) {
            return TRUE;
        };

        //
        node = node-&gt;next;
    }

    return FALSE;
}

//
BOOL file_exists(LPCTSTR szPath) {
    DWORD dwAttrib = GetFileAttributes(szPath);

    return (dwAttrib != INVALID_FILE_ATTRIBUTES &amp;&amp;
        !(dwAttrib &amp; FILE_ATTRIBUTE_DIRECTORY));
}

//
StringList* find_exe_paths(String prog)
{
    // An environment variable has a maximum size limit of 32,767 characters,
    // including the null-terminating character.
    char buf[32767];

    // 8f1kRCu
    DWORD res = GetEnvironmentVariable(TEXT(&quot;PATHEXT&quot;), buf, 32767);

    // 4fpQ2RB
    // If &quot;res&quot; indicates error
    if (res == 0) {
        return NULL;
    }

    // 6qhHTHF
    // Split into a list of extensions
    //
    // Freed at 9nopWXf
    StringList* ext_s = stringlist_create();

    string_split(ext_s, buf, &#39;;&#39;);

    //
    StringNode* node;

    // 2pGJrMW
    // Strip
    node = ext_s-&gt;head;

    while (node) {
        // String &quot;node-&gt;str&quot; is changed in-place
        string_strip((char *)node-&gt;str);

        //
        node = node-&gt;next;
    }

    // 2gqeHHl
    // Remove empty.
    // Must be done after the stripping at 2pGJrMW.
    //
    // Freed at 3vUw4d9
    StringList* ext_s_2 = stringlist_create();

    node = ext_s-&gt;head;

    while (node) {
        // If is not empty string
        if (node-&gt;str[0]) {
            // String &quot;node-&gt;str&quot; is changed ownership
            stringlist_add_end(ext_s_2, node-&gt;str);

            // Clear old pointer
            node-&gt;str = NULL;
        };

        //
        node = node-&gt;next;
    }

    // 9nopWXf
    stringlist_del_v2(&amp;ext_s);

    assert(!ext_s);

    // 2zdGM8W
    // Convert to lowercase
    node = ext_s_2-&gt;head;

    while (node) {
        // String &quot;node-&gt;str&quot; is changed in-place
        string_tolower((char *)node-&gt;str);

        //
        node = node-&gt;next;
    }

    // 2fT8aRB
    // Uniquify
    //
    // Freed at 6b8UxoC
    StringList* ext_s_3 = stringlist_create();

    stringlist_uniq(ext_s_3, ext_s_2);

    // 3vUw4d9
    stringlist_del_v2(&amp;ext_s_2);

    assert(!ext_s_2);

    //
    StringList* dir_path_s = stringlist_create();

    // 4ysaQVN
    res = GetEnvironmentVariable(TEXT(&quot;PATH&quot;), buf, sizeof buf);

    // 5gGwKZL
    // If &quot;res&quot; indicates error
    if (res == 0) {
        // 7bVmOKe
        // Go ahead with &quot;dir_path_s&quot; being empty
        ;
    }
    else {
        // 6mPI0lg
        // Split into a list of dir paths
        string_split(dir_path_s, buf, &#39;;&#39;);
    }

    // 5rT49zI
    // Insert empty dir path to the beginning.
    //
    // Empty dir handles the case that &quot;prog&quot; is a path, either relative or
    // absolute. See code 7rO7NIN.
    stringlist_add_head(dir_path_s, string_copy_new(&quot;&quot;));

    // 2klTv20
    // Uniquify
    //
    // Freed at 6f2j5cZ
    StringList* dir_path_s_2 = stringlist_create();

    stringlist_uniq(dir_path_s_2, dir_path_s);

    // 6f2j5cZ
    stringlist_del_v2(&amp;dir_path_s);

    assert(!dir_path_s);

    // 9gTU1rI
    // Check if &quot;prog&quot; ends with one of the file extension in &quot;ext_s&quot;.
    //
    // &quot;ext_s_3&quot; are all in lowercase, ensured at 2zdGM8W.
    //
    // Freed at 2aR7zCp
    char* prog_lc = string_copy_new(prog);

    string_tolower(prog_lc);

    BOOL prog_has_ext = prog_has_ext_in(prog_lc, ext_s_3);

    // 2aR7zCp
    free(prog_lc);

    // 6bFwhbv
    //
    // Freed at 8swW6Av
    StringList* exe_path_s = stringlist_create();

    node = dir_path_s_2-&gt;head;

    while (node) {
        // 7rO7NIN
        // Synthesize a path
        String dir_path = node-&gt;str;

        String path = NULL;

        // If dir path is empty string
        if (!dir_path[0]) {
            path = prog;
        }
        else {
            // &quot;PathCombine&quot; will not writes more than MAX_PATH chars to &quot;buf&quot;
            assert(sizeof buf &gt;= MAX_PATH);

            LPTSTR res = PathCombine(buf, dir_path, prog);

            // If &quot;res&quot; indicates error
            if (res == NULL) {
                // Ignore
                continue;
            }

            //
            path = buf;
        }

        // 6kZa5cq
        // If &quot;prog&quot; ends with executable file extension
        if (prog_has_ext) {
            // 3whKebE
            if (file_exists(path)) {
                // 2ffmxRF
                stringlist_add_end(exe_path_s, string_copy_new(path));
            }
        }

        // 2sJhhEV
        // Assume user has omitted the file extension
        StringNode* ext_node = ext_s_3-&gt;head;

        while (ext_node) {
            // 6k9X6GP
            // Synthesize a path with one of the file extensions in PATHEXT
            //
            // Freed at 4vT1o9M, or changed ownership at 7dui4cD
            char* path_2 = string_concat_new(path, ext_node-&gt;str);

            // 6kabzQg
            if (file_exists(path_2)) {
                // 7dui4cD
                // &quot;path_2&quot; is changed ownership
                stringlist_add_end(exe_path_s, path_2);
            }
            else {
                // 4vT1o9M
                free(path_2);
            }

            //
            ext_node = ext_node-&gt;next;
        }

        //
        node = node-&gt;next;
    }

    // 6b8UxoC
    stringlist_del_v2(&amp;ext_s_3);

    assert(!ext_s_3);

    // 8swW6Av
    // Uniquify
    StringList* exe_path_s_2 = stringlist_create();

    stringlist_uniq(exe_path_s_2, exe_path_s);

    stringlist_del_v2(&amp;exe_path_s);

    assert(!exe_path_s);

    // 7y3JlnS
    return exe_path_s_2;
};

// 4zKrqsC
// Program entry
int main(int argc, char* argv[])
{
    //
    int exit_code = 0;

    // 9mlJlKg
    // If not exactly one command argument is given
    if (argc != 2) {
        // 7rOUXFo
        // Print program usage
        char const * const usage_txt = &quot;Usage: aoikwinwhich PROG\n&quot;
            &quot;\n&quot;
            &quot;#/ PROG can be either name or path\n&quot;
            &quot;aoikwinwhich notepad.exe\n&quot;
            &quot;aoikwinwhich C:\\Windows\\notepad.exe\n&quot;
            &quot;\n&quot;
            &quot;#/ PROG can be either absolute or relative\n&quot;
            &quot;aoikwinwhich C:\\Windows\\notepad.exe\n&quot;
            &quot;aoikwinwhich Windows\\notepad.exe\n&quot;
            &quot;\n&quot;
            &quot;#/ PROG can be either with or without extension\n&quot;
            &quot;aoikwinwhich notepad.exe\n&quot;
            &quot;aoikwinwhich notepad\n&quot;
            &quot;aoikwinwhich C:\\Windows\\notepad.exe\n&quot;
            &quot;aoikwinwhich C:\\Windows\\notepad&quot;;

        printf(&quot;%s&quot;, usage_txt);

        // 3nqHnP7
        exit_code = 1;

        return exit_code;
    }

    //
    assert(argc == 2);

    // 9m5B08H
    // Get executable name or path
    String prog = argv[1];

    // 8ulvPXM
    // Find executable paths
    //
    // Freed at 2jUVFP0
    StringList* exe_path_s = find_exe_paths(prog);

    // 5fWrcaF
    // If has found none
    if (!exe_path_s || !exe_path_s-&gt;count) {
        // 3uswpx0
        exit_code = 2;
    }
    // If has found some
    else {
        // 9xPCWuS
        // Print result
        StringNode* node = exe_path_s-&gt;head;

        while (node) {
            //
            printf(&quot;%s\n&quot;, node-&gt;str);

            //
            node = node-&gt;next;
        }

        // 4s1yY1b
        exit_code = 0;
    }

    // 2jUVFP0
    if (exe_path_s) {
        stringlist_del_v2(&amp;exe_path_s);

        assert(!exe_path_s);
    }

    //
    return exit_code;
}</code></pre><h2 id="aoikwinwhich-ceylon"><a class="anchor" href="#aoikwinwhich-ceylon"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Ceylon</h2><pre><code>//
import ceylon.collection { LinkedList }
import java.io { File }
import java.lang { System }
import java.nio.file { Files, Paths }

shared object aoikWinWhich {

    shared {String*} uniq({String*} item_s) {
        value item_s_new = LinkedList&lt;String&gt;();

        for (item in item_s) {
            if (!(item in item_s_new)) {
                item_s_new.add(item);
            }
        }

        return item_s_new;
    }

    shared {String*} find_executable(String prog) {
        // 8f1kRCu
        value env_var_PATHEXT = System.getenv(&quot;PATHEXT&quot;) else &quot;&quot;;

        // 6qhHTHF
        // split into a list of extensions
        variable {String*} ext_s = (env_var_PATHEXT == &quot;&quot;)
            then {}    
            else env_var_PATHEXT.split((x) =&gt; x == (File.pathSeparator[0] else &#39;;&#39;));

        // 2pGJrMW
        // strip
        ext_s = ext_s.map((x) =&gt; x.trim(&#39; &#39;.equals));

        // 2gqeHHl
        // remove empty
        ext_s = ext_s.filter((x) =&gt; x != &quot;&quot;);

        // 2zdGM8W
        // convert to lowercase
        ext_s = ext_s.map((x) =&gt; x.lowercased);

        // 2fT8aRB
        // uniquify
        ext_s = uniq(ext_s);

        value ext_s2 = LinkedList&lt;String&gt;(ext_s);

        // 4ysaQVN
        value env_var_PATH = System.getenv(&quot;PATH&quot;) else &quot;&quot;;

        // 6mPI0lg
        variable LinkedList&lt;String&gt; dir_path_s = (env_var_PATH == &quot;&quot;)
            then LinkedList&lt;String&gt;()
            else LinkedList&lt;String&gt;(env_var_PATH.split((x) =&gt; x == (File.pathSeparator[0] else &#39;;&#39;)));

        // 5rT49zI
        // insert empty dir path to the beginning
        //
        // Empty dir handles the case that |prog| is a path, either relative or
        //  absolute. See code 7rO7NIN.
        dir_path_s.insert(0, &quot;&quot;);

        // 2klTv20
        // uniquify
        dir_path_s = LinkedList&lt;String&gt;(uniq(dir_path_s));

        //
        value prog_lc = prog.lowercased;

        value prog_has_ext = ext_s2.any((ext) =&gt; prog_lc.endsWith(ext));

        // 6bFwhbv
        value exe_path_s = LinkedList&lt;String&gt;();

        for (dir_path in dir_path_s) {
            // 7rO7NIN
            // synthesize a path with the dir and prog
            value path = (dir_path == &quot;&quot;)
                then prog
                else Paths.get(dir_path, prog).string;

            // 6kZa5cq
            // assume the path has extension, check if it is an executable
            if (prog_has_ext &amp;&amp; Files.isRegularFile(Paths.get(path))) {
                 exe_path_s.add(path);
            }

            // 2sJhhEV
            // assume the path has no extension
            for (ext in ext_s) {
                // 6k9X6GP
                // synthesize a new path with the path and the executable extension
                value path_plus_ext = path + ext;

                // 6kabzQg
                // check if it is an executable
                if (Files.isRegularFile(Paths.get(path_plus_ext))) {
                    exe_path_s.add(path_plus_ext);
                }
            }
        }

        // 8swW6Av
        // uniquify
        value exe_path_s2 = uniq(exe_path_s);

        //
        return exe_path_s2;
    }

    shared void main() {
        // 9mlJlKg
        // check if one cmd arg is given
        if (process.arguments.size != 1) {
            // 7rOUXFo
            // print program usage
            print(&quot;Usage: aoikwinwhich PROG&quot;);
            print(&quot;&quot;);
            print(&quot;#/ PROG can be either name or path&quot;);
            print(&quot;aoikwinwhich notepad.exe&quot;);
            print(&quot;aoikwinwhich C:\\Windows\\notepad.exe&quot;);
            print(&quot;&quot;);
            print(&quot;#/ PROG can be either absolute or relative&quot;);
            print(&quot;aoikwinwhich C:\\Windows\\notepad.exe&quot;);
            print(&quot;aoikwinwhich Windows\\notepad.exe&quot;);
            print(&quot;&quot;);
            print(&quot;#/ PROG can be either with or without extension&quot;);
            print(&quot;aoikwinwhich notepad.exe&quot;);
            print(&quot;aoikwinwhich notepad&quot;);
            print(&quot;aoikwinwhich C:\\Windows\\notepad.exe&quot;);
            print(&quot;aoikwinwhich C:\\Windows\\notepad&quot;);

            // 3nqHnP7
            return;
        }

        // 9m5B08H
        // get name or path of a program from cmd arg
        value prog = process.arguments[0] else &quot;&quot;;

        // 8ulvPXM
        // find executables
        value path_s = find_executable(prog);

        // 5fWrcaF
        // has found none, exit
        if (path_s.size == 0) {
            // 3uswpx0
            return;
        }

        // 9xPCWuS
        // has found some, output
        value txt = &quot;\n&quot;.join(path_s);

        print(txt);

        // 4s1yY1b
        return;
    }
}

// define a toplevel method |aoikwinwhich::main|
shared void main() {
    aoikWinWhich.main();
}</code></pre><h2 id="aoikwinwhich-clojure"><a class="anchor" href="#aoikwinwhich-clojure"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Clojure</h2><pre><code>;;
(ns aoikwinwhich)

(require &#39;[clojure.string :refer [join]])
(require &#39;[clojure.string :refer [split]])
(import java.io.File)
(import java.lang.System)
(import java.nio.file.Files)
(import java.nio.file.LinkOption)
(import java.nio.file.Paths)
(import java.util.LinkedList)

;;
(defn -path_make
[part_s]
    (.toString (Paths/get &quot;&quot; (into-array part_s)))
)

(defn -file_exists
[path]
    (Files/isRegularFile (Paths/get &quot;&quot; (into-array [path])) (make-array LinkOption 0))
)

(defn -find_executable
[prog]
    (let [
        ;; 8f1kRCu
        env_var_PATHEXT (. System getenv &quot;PATHEXT&quot;)
        ;;; can be nil

        ;; 4ysaQVN
        env_var_PATH (. System getenv &quot;PATH&quot;)
        ;;; can be nil

        val_sep_re (re-pattern File/pathSeparator)
        ]

        ;;
        (let [
            ext_s
                ;; 2fT8aRB
                ;; uniquify
                (distinct
                    ;; 2zdGM8W
                    ;; convert to lowercase
                    (map #(.toLowerCase %1)
                        ;; 2gqeHHl
                        ;; remove empty
                        (filter #(not (= %1 &quot;&quot;))
                            ;; 2pGJrMW
                            ;; strip
                            (map #(.trim %1)
                                ;; 6qhHTHF
                                ;; split into a list of extensions
                                (if (nil? env_var_PATHEXT)
                                    ([])
                                    (split env_var_PATHEXT val_sep_re)
                                )
                            )
                        )
                    )
                )
            ]

            ;;
            (let [
                dir_path_s
                    ;; 2klTv20
                    ;; uniquify
                    (distinct
                        ;; 5rT49zI
                        ;; insert empty dir path to the beginning
                        ;;
                        ;; Empty dir handles the case that |prog| is a path, either relative or
                        ;;  absolute. See code 7rO7NIN.
                        (into [&quot;&quot;]
                            ;; 6mPI0lg
                            (if (nil? env_var_PATH)
                                ([])
                                (split env_var_PATH val_sep_re)
                            )
                        )
                    )
                ]

                ;; 6bFwhbv
                (let [
                    exe_path_s (LinkedList.)
                    prog_lower (.toLowerCase prog)
                    prog_has_ext
                        (some #(. prog_lower endsWith %1) ext_s)
                    ]
                    (doseq [dir_path dir_path_s]
                        ;; 7rO7NIN
                        ;; synthesize a path with the dir and prog
                        (let [
                            path
                                (if (= dir_path &quot;&quot;)
                                    prog
                                    (-path_make [dir_path prog])
                                )

                            ]

                            ;; 6kZa5cq
                            ;; assume the path has extension, check if it is an executable
                            (if (and prog_has_ext (-file_exists path))
                                (. exe_path_s add path)
                                ()
                            )

                            ;; 2sJhhEV
                            ;; assume the path has no extension
                            (doseq [ext ext_s]
                                ;; 6k9X6GP
                                ;; synthesize a new path with the path and the executable extension
                                (let [
                                    path_plus_ext (str path ext)
                                    ]

                                    ;; 6kabzQg
                                    ;; check if it is an executable
                                    (if (-file_exists path_plus_ext)
                                        (. exe_path_s add path_plus_ext)
                                        ()
                                    )
                                )
                            )
                        )
                    )

                    ;; func res
                    exe_path_s
                )
            )
        )
    )
)

(defn -main
[]
;; 9mlJlKg
;; check if one cmd arg is given
    (if (not (= 1 (count *command-line-args*)))
        (do
            ;; 7rOUXFo
            ;; print program usage
            (println &quot;Usage: aoikwinwhich PROG&quot;)
            (println &quot;&quot;)
            (println &quot;#/ PROG can be either name or path&quot;)
            (println &quot;aoikwinwhich notepad.exe&quot;)
            (println &quot;aoikwinwhich C:\\Windows\\notepad.exe&quot;)
            (println &quot;&quot;)
            (println &quot;#/ PROG can be either absolute or relative&quot;)
            (println &quot;aoikwinwhich C:\\Windows\\notepad.exe&quot;)
            (println &quot;aoikwinwhich Windows\\notepad.exe&quot;)
            (println &quot;&quot;)
            (println &quot;#/ PROG can be either with or without extension&quot;)
            (println &quot;aoikwinwhich notepad.exe&quot;)
            (println &quot;aoikwinwhich notepad&quot;)
            (println &quot;aoikwinwhich C:\\Windows\\notepad.exe&quot;)
            (println &quot;aoikwinwhich C:\\Windows\\notepad&quot;)

            ;; 3nqHnP7
            ()
        )
        (do
            ;; 9m5B08H
            ;; get name or path of a program from cmd arg
            (let [prog (nth *command-line-args* 0)]
                ;; 8ulvPXM
                ;; find executables
                (let [path_s (-find_executable prog)]
                    (if (= (.size path_s) 0)
                        ;; 5fWrcaF
                        ;; has found none, exit
                        ;; 3uswpx0
                        ()

                        ;; 9xPCWuS
                        ;; has found some, output
                        (do
                            (println (join &quot;\n&quot; path_s))

                            ;; 4s1yY1b
                            ()
                        )
                    )
                )
            )
        )
    )
)

(-main)</code></pre><h2 id="aoikwinwhich-coffeescript"><a class="anchor" href="#aoikwinwhich-coffeescript"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-CoffeeScript</h2><pre><code>#/
&#39;use strict&#39;

#/
_fs = require &#39;fs&#39;
_path = require &#39;path&#39;
_ = require &#39;underscore&#39;

#/ add func |endsWith| to String
String::endsWith ?= (s) -&gt; s == &#39;&#39; or @slice(-s.length) == s

#/
is_file = (path) -&gt;
    fstat = null
    try
        fstat = _fs.statSync(path)
    catch err
        return false

    return fstat &amp;&amp; fstat.isFile()

find_executable = (prog) -&gt;
    #/ 8f1kRCu
    env_var_PATHEXT = process.env.PATHEXT
    ## can be |undefined|

    #/ 6qhHTHF
    #/ split into a list of extensions
    ext_s = if !env_var_PATHEXT \
        then []
        else env_var_PATHEXT.split(_path.delimiter)

    #/ 2pGJrMW
    #/ strip
    ext_s = (ext.trim() for ext in ext_s)

    #/ 2gqeHHl
    #/ remove empty
    ext_s = (ext for ext in ext_s when ext != &#39;&#39;)

    #/ 2zdGM8W
    #/ convert to lowercase
    ext_s = (ext.toLowerCase() for ext in ext_s)

    #/ 2fT8aRB
    #/ uniquify
    ext_s = _.uniq(ext_s)

    #/ 4ysaQVN
    env_var_PATH = process.env.PATH
    #// can be |undefined|
    #//
    #// if has value, there is an ending || in it,
    #//  which results in an ending empty string for the splitting at 3zVznlK

    #/ 6mPI0lg
    dir_path_s = if !env_var_PATH \
        then []
        else env_var_PATH.split(_path.delimiter)
        ## 3zVznlK

    #/ 5rT49zI
    #/ insert empty dir path to the beginning
    #/
    #/ Empty dir handles the case that |prog| is a path, either relative or absolute.
    #/ See code 7rO7NIN.
    dir_path_s.unshift(&#39;&#39;)

    #/ 2klTv20
    #/ uniquify
    dir_path_s = _.uniq(dir_path_s)

    #/ 6bFwhbv
    exe_path_s = []

    _.each(dir_path_s, (dir_path) -&gt;
        #/ 7rO7NIN
        #/ synthesize a path with the dir and prog
        path = _path.join(dir_path, prog)

        #/ 6kZa5cq
        #/ assume the path has extension, check if it is an executable
        if _.any(ext_s, (ext) -&gt; path.endsWith(ext))
            if is_file(path)
                exe_path_s.push(path)

        #/ 2sJhhEV
        #/ assume the path has no extension
        _.each(ext_s, (ext) -&gt;
            #/ 6k9X6GP
            #/ synthesize a new path with the path and the executable extension
            path_plus_ext = path + ext

            #/ 6kabzQg
            #/ check if it is an executable
            if is_file(path_plus_ext)
                exe_path_s.push(path_plus_ext)
        )
    )

    #/ 8swW6Av
    #/ uniquify
    exe_path_s = _.uniq(exe_path_s)

    #/
    return exe_path_s

println = (txt) -&gt;
    process.stdout.write(txt + &#39;\n&#39;)

main = -&gt;
    #/ 9mlJlKg
    #/ check if one cmd arg is given
    arg_s = process.argv.slice(2)

    if arg_s.length != 1
        #/ 7rOUXFo
        #/ print program usage
        println &#39;Usage: aoikwinwhich PROG&#39;
        println &#39;&#39;
        println &#39;#/ PROG can be either name or path&#39;
        println &#39;aoikwinwhich notepad.exe&#39;
        println &#39;aoikwinwhich C:\\Windows\\notepad.exe&#39;
        println &#39;&#39;
        println &#39;#/ PROG can be either absolute or relative&#39;
        println &#39;aoikwinwhich C:\\Windows\\notepad.exe&#39;
        println &#39;aoikwinwhich Windows\\notepad.exe&#39;
        println &#39;&#39;
        println &#39;#/ PROG can be either with or without extension&#39;
        println &#39;aoikwinwhich notepad.exe&#39;
        println &#39;aoikwinwhich notepad&#39;
        println &#39;aoikwinwhich C:\\Windows\\notepad.exe&#39;
        println &#39;aoikwinwhich C:\\Windows\\notepad&#39;

        #/ 3nqHnP7
        return

    #/ 9m5B08H
    #/ get name or path of a program from cmd arg
    prog = arg_s[0]

    #/ 8ulvPXM
    #/ find executables
    path_s = find_executable(prog)

    #/ 5fWrcaF
    #/ has found none, exit
    if !path_s.length
        #/ 3uswpx0
        return

    #/ 9xPCWuS
    #/ has found some, output
    txt = path_s.join(&#39;\n&#39;)

    println txt

    #/ 4s1yY1b
    return

#/
exports.main = main

#/
if require.main == module
    main()</code></pre><h2 id="aoikwinwhich-cpp"><a class="anchor" href="#aoikwinwhich-cpp"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Cpp</h2><pre><code>//
#include &quot;stdafx.h&quot;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;list&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;windows.h&gt;
#include &lt;Shlwapi.h&gt;
#pragma comment(lib, &quot;Shlwapi.lib&quot;)

//
using namespace std;

//
#ifdef _UNICODE
#define WA_COUT wcout
#define WA_STRING wstring
#else
#define WA_COUT cout
#define WA_STRING string
#endif

// Modified from http://stackoverflow.com/questions/236129/split-a-string-in-c/7408245#7408245
// --- BEG
void string_split(list&lt;WA_STRING&gt; &amp;tokens, const WA_STRING &amp;text, char sep) {
    int start = 0, end = 0;
    while ((end = text.find(sep, start)) != WA_STRING::npos) {
        tokens.push_back(text.substr(start, end - start));
        start = end + 1;
    }
    tokens.push_back(text.substr(start));
}
// --- END

// Modified from http://stackoverflow.com/questions/216823/whats-the-best-way-to-trim-stdstring/15649849#15649849
// --- BEG
WA_STRING string_strip(const WA_STRING&amp; s) {
    const WA_STRING&amp; chars = TEXT(&quot; &quot;);
    size_t begin = 0;
    size_t end = s.size() - 1;
    for (; begin &lt; s.size(); begin++)
        if (chars.find_first_of(s[begin]) == WA_STRING::npos)
            break;
    for (; end &gt; begin; end--)
        if (chars.find_first_of(s[end]) == WA_STRING::npos)
            break;
    return s.substr(begin, end - begin + 1);
}
// --- END

//
WA_STRING string_tolower(WA_STRING str) {
    std::transform(str.begin(), str.end(), str.begin(), ::tolower);
    return str;
}

// Modified from http://stackoverflow.com/questions/874134/find-if-string-endswith-another-string-in-c/874160#874160
BOOL string_endswith(WA_STRING const &amp;str, WA_STRING const &amp;end) {
    if (str.length() &gt;= end.length()) {
        return (0 == str.compare(str.length() - end.length(), end.length(), end));
    }
    else {
        return false;
    }
}

//
void list_strip(list&lt;WA_STRING&gt;&amp; item_s) {
    std::transform(item_s.begin(), item_s.end(), item_s.begin(), string_strip);
}

//
void list_remove_empty(list&lt;WA_STRING&gt;&amp; item_s) {
    list&lt;WA_STRING&gt;::iterator iter = item_s.begin();

    while (iter != item_s.end()) {
        // if current item is empty string
        if (*iter == TEXT(&quot;&quot;)) {
            iter = item_s.erase(iter);
        }
        else {
            ++iter;
        }
    }
}

//
void list_tolower(list&lt;WA_STRING&gt;&amp; item_s) {
    std::transform(item_s.begin(), item_s.end(), item_s.begin(), string_tolower);
}

// Modified from http://stackoverflow.com/questions/4885676/remove-duplicates-from-a-listint/4885787#4885787
// --- BEG
void list_uniq(list&lt;WA_STRING&gt;&amp; item_s) {
    list&lt;WA_STRING&gt;::iterator iter = item_s.begin();

    set&lt;WA_STRING&gt; item_s_met;

    while (iter != item_s.end()) {
        // if current item has been met before
        if (item_s_met.find(*iter) != item_s_met.end()) {
            iter = item_s.erase(iter);
        }
        else {
            item_s_met.insert(*iter);
            ++iter;
        }
    }
}
// --- END

//
BOOL prog_has_ext_in(WA_STRING prog, list&lt;WA_STRING&gt; ext_s) {
    for (list&lt;WA_STRING&gt;::const_iterator iter = ext_s.begin(); iter != ext_s.end(); ++iter) {
        if (string_endswith(prog, *iter)) {
            return true;
        }
    }
    return false;
}

//
BOOL file_exists(LPCTSTR szPath) {
    DWORD dwAttrib = GetFileAttributes(szPath);

    return (dwAttrib != INVALID_FILE_ATTRIBUTES &amp;&amp;
        !(dwAttrib &amp; FILE_ATTRIBUTE_DIRECTORY));
}

//
list&lt;WA_STRING&gt;* find_exe_paths(LPCTSTR prog) {
    // An environment variable has a maximum size limit of 32,767 characters,
    // including the null-terminating character.
    TCHAR buf[32767];

    // 8f1kRCu
    DWORD res = GetEnvironmentVariable(TEXT(&quot;PATHEXT&quot;), buf, 32767);

    // 4fpQ2RB
    // If &quot;res&quot; indicates error
    if (res == 0) {
        return NULL;
    }

    // 6qhHTHF
    // Split into a list of extensions
    list&lt;WA_STRING&gt; ext_s;

    WA_STRING env_pathext(buf);

    string_split(ext_s, env_pathext, &#39;;&#39;);

    // 2pGJrMW
    // Strip
    list_strip(ext_s);

    // 2gqeHHl
    // Remove empty.
    // Must be done after the stripping at 2pGJrMW.
    list_remove_empty(ext_s);

    // 2zdGM8W
    // Convert to lowercase
    list_tolower(ext_s);

    // 2fT8aRB
    // Uniquify
    list_uniq(ext_s);

    //
    list&lt;WA_STRING&gt; dir_path_s;

    // 4ysaQVN
    res = GetEnvironmentVariable(TEXT(&quot;PATH&quot;), buf, sizeof buf);

    // 5gGwKZL
    // If &quot;res&quot; indicates error
    if (res == 0) {
        // 7bVmOKe
        // Go ahead with &quot;dir_path_s&quot; being empty
        ;
    }
    else {
        // 6mPI0lg
        // Split into a list of dir paths
        WA_STRING env_path(buf);

        string_split(dir_path_s, env_path, &#39;;&#39;);
    }

    // 5rT49zI
    // Insert empty dir path to the beginning.
    //
    // Empty dir handles the case that &quot;prog&quot; is a path, either relative or
    // absolute. See code 7rO7NIN.
    dir_path_s.push_front(TEXT(&quot;&quot;));

    // 2klTv20
    // Uniquify
    list_uniq(dir_path_s);

    // 9gTU1rI
    // Check if &quot;prog&quot; ends with one of the file extension in &quot;ext_s&quot;.
    //
    // &quot;ext_s&quot; are all in lowercase, ensured at 2zdGM8W.
    BOOL prog_has_ext = prog_has_ext_in(string_tolower(prog), ext_s);

    // 6bFwhbv
    list&lt;WA_STRING&gt; *exe_path_s = new list&lt;WA_STRING&gt;();

    for (list&lt;WA_STRING&gt;::const_iterator iter = dir_path_s.begin(); iter != dir_path_s.end(); ++iter) {
        // 7rO7NIN
        // Synthesize a path
        WA_STRING dir_path = *iter;

        WA_STRING path;

        // If dir path is empty string
        if (dir_path == TEXT(&quot;&quot;)) {
            path = WA_STRING(prog);
        }
        else {
            // &quot;PathCombine&quot; will not writes more than MAX_PATH chars to &quot;buf&quot;
            assert(sizeof buf &gt;= MAX_PATH);

            LPTSTR res = PathCombine(buf, dir_path.c_str(), prog);

            // If &quot;res&quot; indicates error
            if (res == NULL) {
                // Ignore
                continue;
            }

            //
            path = WA_STRING(buf);
        }

        // 6kZa5cq
        // If &quot;prog&quot; ends with executable file extension
        if (prog_has_ext) {
            // 3whKebE
            if (file_exists(path.c_str())) {
                // 2ffmxRF
                exe_path_s-&gt;push_back(path);
            }
        }

        // 2sJhhEV
        // Assume user has omitted the file extension
        for (list&lt;WA_STRING&gt;::const_iterator iter = ext_s.begin(); iter != ext_s.end(); ++iter) {
            // 6k9X6GP
            // Synthesize a path with one of the file extensions in PATHEXT
            WA_STRING ext = *iter;

            WA_STRING path_2 = path + ext;

            // 6kabzQg
            if (file_exists(path_2.c_str())) {
                exe_path_s-&gt;push_back(path_2);
            }
        }
    }

    // 8swW6Av
    // Uniquify
    list_uniq(*exe_path_s);

    // 7y3JlnS
    return exe_path_s;
}

// 4zKrqsC
// Program entry
int _tmain(int argc, _TCHAR* argv[])
{
    //
    int exit_code = 0;

    // 9mlJlKg
    // If not exactly one command argument is given
    if (argc != 2) {
        // 7rOUXFo
        // print program usage
        string usage_txt = &quot;Usage: aoikwinwhich PROG\n&quot;
            &quot;\n&quot;
            &quot;#/ PROG can be either name or path\n&quot;
            &quot;aoikwinwhich notepad.exe\n&quot;
            &quot;aoikwinwhich C:\\Windows\\notepad.exe\n&quot;
            &quot;\n&quot;
            &quot;#/ PROG can be either absolute or relative\n&quot;
            &quot;aoikwinwhich C:\\Windows\\notepad.exe\n&quot;
            &quot;aoikwinwhich Windows\\notepad.exe\n&quot;
            &quot;\n&quot;
            &quot;#/ PROG can be either with or without extension\n&quot;
            &quot;aoikwinwhich notepad.exe\n&quot;
            &quot;aoikwinwhich notepad\n&quot;
            &quot;aoikwinwhich C:\\Windows\\notepad.exe\n&quot;
            &quot;aoikwinwhich C:\\Windows\\notepad&quot;;

        //
        cout &lt;&lt; usage_txt &lt;&lt; endl;

        // 3nqHnP7
        exit_code = 1;

        return exit_code;
    }

    // 9m5B08H
    // Get executable name or path
    LPCTSTR prog = argv[1];

    // 8ulvPXM
    // Find executable paths
    //
    // Freed at 2jUVFP0
    list&lt;WA_STRING&gt;* exe_path_s = find_exe_paths(prog);

    // 5fWrcaF
    // If has found none
    if (!exe_path_s || !exe_path_s-&gt;size()) {
        // 3uswpx0
        exit_code = 2;
    }
    // If has found some
    else {
        // 9xPCWuS
        // Print result
        for (list&lt;WA_STRING&gt;::const_iterator iter = exe_path_s-&gt;begin();
            iter != exe_path_s-&gt;end();
            ++iter) {
            WA_COUT &lt;&lt; WA_STRING(*iter) &lt;&lt; endl;
        }

        // 4s1yY1b
        exit_code = 0;
    }

    // 2jUVFP0
    if (exe_path_s) {
        delete(exe_path_s);
    }

    //
    return exit_code;
}</code></pre><h2 id="aoikwinwhich-cpp-cli"><a class="anchor" href="#aoikwinwhich-cpp-cli"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Cpp-CLI</h2><pre><code>//
#include &quot;stdafx.h&quot;

using namespace System;
using namespace System::Collections::Generic;
using namespace System::IO;

//
bool contain (List&lt;String^&gt;^ item_s, String^ item) {
    for each (String^ itemx in item_s) {
      if (itemx-&gt;Equals(item)) {
        return true;
      }
    }

    return false;
}

List&lt;String^&gt;^ uniq (List&lt;String^&gt;^ item_s) {
  List&lt;String^&gt;^ item_s_new = gcnew List&lt;String^&gt;();

  for each (String^ item in item_s) {
    if (!contain(item_s_new, item)) {
      item_s_new-&gt;Add(item);
    }
  }

  return item_s_new;
}

List&lt;String^&gt;^ find_executable (String^ prog) {
    // 8f1kRCu
    String^ env_var_PATHEXT = Environment::GetEnvironmentVariable(&quot;PATHEXT&quot;);
    /// can be nullptr

    // 6qhHTHF
    // split into a list of extensions
    List&lt;String^&gt;^ ext_s = (env_var_PATHEXT == nullptr)
        ? gcnew List&lt;String^&gt;()
        : gcnew List&lt;String^&gt;(env_var_PATHEXT-&gt;Split(Path::PathSeparator));

    // 2pGJrMW
    // strip
  List&lt;String^&gt;^ ext_s_old = ext_s;

  ext_s = gcnew List&lt;String^&gt;();

  for each (String^ ext in ext_s_old) {
    ext_s-&gt;Add(ext-&gt;Trim());
  }

    // 2gqeHHl
    // remove empty
  ext_s_old = ext_s;

  ext_s = gcnew List&lt;String^&gt;();

  for each (String^ ext in ext_s_old) {
    if (!ext-&gt;Equals(&quot;&quot;)) {
      ext_s-&gt;Add(ext);
    }
  }

    // 2zdGM8W
    // convert to lowercase
  ext_s_old = ext_s;

  ext_s = gcnew List&lt;String^&gt;();

  for each (String^ ext in ext_s_old) {
    ext_s-&gt;Add(ext-&gt;ToLower());
  }

    // 2fT8aRB
    // uniquify
  ext_s = uniq(ext_s);

    // 4ysaQVN
    String^ env_var_PATH = Environment::GetEnvironmentVariable(&quot;PATH&quot;);
    /// can be nullptr

    List&lt;String^&gt;^ dir_path_s = (env_var_PATH == nullptr)
        ? gcnew List&lt;String^&gt;()
        : gcnew List&lt;String^&gt;(env_var_PATH-&gt;Split(Path::PathSeparator));

    // 5rT49zI
    // insert empty dir path to the beginning
    //
    // Empty dir handles the case that |prog| is a path, either relative or
    //  absolute. See code 7rO7NIN.
    dir_path_s-&gt;Insert(0, &quot;&quot;);

    // 2klTv20
    // uniquify
    dir_path_s = uniq(dir_path_s);

    //
    String^ prog_lc = prog-&gt;ToLower();

    bool prog_has_ext = false;

  for each (String^ ext in ext_s) {
    if (prog_lc-&gt;EndsWith(ext)) {
      prog_has_ext = true;
    }
  }

    // 6bFwhbv
    List&lt;String^&gt;^ exe_path_s = gcnew List&lt;String^&gt;();

  for each (String^ dir_path in dir_path_s) {
        // 7rO7NIN
        // synthesize a path with the dir and prog
        String^ path = (dir_path-&gt;Equals(&quot;&quot;))
            ? prog
            : Path::Combine(dir_path, prog);

        // 6kZa5cq
        // assume the path has extension, check if it is an executable
        if (prog_has_ext &amp;&amp; File::Exists(path))
        {
            exe_path_s-&gt;Add(path);
        }

        // 2sJhhEV
        // assume the path has no extension
    for each (String^ ext in ext_s) {
            // 6k9X6GP
            // synthesize a new path with the path and the executable extension
            String^ path_plus_ext = path + ext;

            // 6kabzQg
            // check if it is an executable
      if (File::Exists(path_plus_ext))
      {
        exe_path_s-&gt;Add(path_plus_ext);
      }
    }
  }

    // 8swW6Av
    // uniquify
    exe_path_s = uniq(exe_path_s);

  //
  return exe_path_s;
}

int main(array&lt;String ^&gt; ^args)
{
    // 9mlJlKg
    if (args-&gt;Length != 1)
    {
        // 7rOUXFo
        // print program usage
        Console::WriteLine(&quot;Usage: aoikwinwhich PROG&quot;);
        Console::WriteLine(&quot;&quot;);
        Console::WriteLine(&quot;#/ PROG can be either name or path&quot;);
        Console::WriteLine(&quot;aoikwinwhich notepad.exe&quot;);
        Console::WriteLine(&quot;aoikwinwhich C:\\Windows\\notepad.exe&quot;);
        Console::WriteLine(&quot;&quot;);
        Console::WriteLine(&quot;#/ PROG can be either absolute or relative&quot;);
        Console::WriteLine(&quot;aoikwinwhich C:\\Windows\\notepad.exe&quot;);
        Console::WriteLine(&quot;aoikwinwhich Windows\\notepad.exe&quot;);
        Console::WriteLine(&quot;&quot;);
        Console::WriteLine(&quot;#/ PROG can be either with or without extension&quot;);
        Console::WriteLine(&quot;aoikwinwhich notepad.exe&quot;);
        Console::WriteLine(&quot;aoikwinwhich notepad&quot;);
        Console::WriteLine(&quot;aoikwinwhich C:\\Windows\\notepad.exe&quot;);
        Console::WriteLine(&quot;aoikwinwhich C:\\Windows\\notepad&quot;);

        // 3nqHnP7
        return 2;
    }

    // 9m5B08H
    // get name or path of a program from cmd arg
    String^ prog = args[0];

    // 8ulvPXM
    // find executables
  List&lt;String^&gt;^ path_s = find_executable(prog);

    // 5fWrcaF
    // has found none, exit
    if (path_s-&gt;Count == 0)
    {
        // 3uswpx0
        return 1;
    }

  // 9xPCWuS
  // has found some, output
  String^ txt = String::Join(&quot;\n&quot;, path_s);

    Console::WriteLine(txt);

    // 4s1yY1b
    return 0;
}</code></pre><h2 id="aoikwinwhich-csharp"><a class="anchor" href="#aoikwinwhich-csharp"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-CSharp</h2><pre><code>//
using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;

//
namespace AoikWinWhich
{
    class AoikWinWhich
    {
        static List&lt;String&gt; find_executable(String prog)
        {
            // 8f1kRCu
            var env_var_PATHEXT = Environment.GetEnvironmentVariable(&quot;PATHEXT&quot;);
            /// can be null

            // 6qhHTHF
            // split into a list of extensions
            var ext_s = (env_var_PATHEXT == null)
                ? new List&lt;String&gt;()
                : new List&lt;String&gt;(env_var_PATHEXT.Split(Path.PathSeparator));

            // 2pGJrMW
            // strip
            ext_s = ext_s.Select(x =&gt; x.Trim()).ToList();

            // 2gqeHHl
            // remove empty
            ext_s = ext_s.Where(x =&gt; x != &quot;&quot;).ToList();

            // 2zdGM8W
            // convert to lowercase
            ext_s = ext_s.Select(x =&gt; x.ToLower()).ToList();

            // 2fT8aRB
            // uniquify
            ext_s = ext_s.Distinct().ToList();

            // 4ysaQVN
            var env_var_PATH = Environment.GetEnvironmentVariable(&quot;PATH&quot;);
            /// can be null

            var dir_path_s = (env_var_PATH == null)
                ? new List&lt;String&gt;()
                : new List&lt;String&gt;(env_var_PATH.Split(Path.PathSeparator));

            // 5rT49zI
            // insert empty dir path to the beginning
            //
            // Empty dir handles the case that |prog| is a path, either relative or
            //  absolute. See code 7rO7NIN.
            dir_path_s.Insert(0, &quot;&quot;);

            // 2klTv20
            // uniquify
            dir_path_s = dir_path_s.Distinct().ToList();

            //
            var prog_lc = prog.ToLower();

            var prog_has_ext = ext_s.Any(ext =&gt; prog_lc.EndsWith(ext));

            // 6bFwhbv
            var exe_path_s = new List&lt;String&gt;();

            foreach (var dir_path in dir_path_s)
            {
                // 7rO7NIN
                // synthesize a path with the dir and prog
                var path = (dir_path == &quot;&quot;)
                    ? prog
                    : Path.Combine(dir_path, prog);

                // 6kZa5cq
                // assume the path has extension, check if it is an executable
                if (prog_has_ext &amp;&amp; File.Exists(path))
                {
                    exe_path_s.Add(path);
                }

                // 2sJhhEV
                // assume the path has no extension
                foreach (var ext in ext_s)
                {
                    // 6k9X6GP
                    // synthesize a new path with the path and the executable extension
                    var path_plus_ext = path + ext;

                    // 6kabzQg
                    // check if it is an executable
                    if (File.Exists(path_plus_ext))
                    {
                        exe_path_s.Add(path_plus_ext);
                    }
                }
            }

            // 8swW6Av
            // uniquify
            exe_path_s = exe_path_s.Distinct().ToList();

            //
            return exe_path_s;
        }

        static void Main(String[] args)
        {
            // 9mlJlKg
            if (args.Length != 1)
            {
                // 7rOUXFo
                // print program usage
                Console.WriteLine(@&quot;Usage: aoikwinwhich PROG&quot;);
                Console.WriteLine(@&quot;&quot;);
                Console.WriteLine(@&quot;#/ PROG can be either name or path&quot;);
                Console.WriteLine(@&quot;aoikwinwhich notepad.exe&quot;);
                Console.WriteLine(@&quot;aoikwinwhich C:\Windows\notepad.exe&quot;);
                Console.WriteLine(@&quot;&quot;);
                Console.WriteLine(@&quot;#/ PROG can be either absolute or relative&quot;);
                Console.WriteLine(@&quot;aoikwinwhich C:\Windows\notepad.exe&quot;);
                Console.WriteLine(@&quot;aoikwinwhich Windows\notepad.exe&quot;);
                Console.WriteLine(@&quot;&quot;);
                Console.WriteLine(@&quot;#/ PROG can be either with or without extension&quot;);
                Console.WriteLine(@&quot;aoikwinwhich notepad.exe&quot;);
                Console.WriteLine(@&quot;aoikwinwhich notepad&quot;);
                Console.WriteLine(@&quot;aoikwinwhich C:\Windows\notepad.exe&quot;);
                Console.WriteLine(@&quot;aoikwinwhich C:\Windows\notepad&quot;);

                // 3nqHnP7
                return;
            }

            // 9m5B08H
            // get name or path of a program from cmd arg
            var prog = args[0];

            // 8ulvPXM
            // find executables
            var path_s = find_executable(prog);

            // 5fWrcaF
            // has found none, exit
            if (path_s.Count == 0)
            {
                // 3uswpx0
                return;
            }

            // 9xPCWuS
            // has found some, output
            var txt = String.Join(&quot;\n&quot;, path_s);

            Console.WriteLine(txt);

            // 4s1yY1b
            return;
        }
    }
}</code></pre><h2 id="aoikwinwhich-d"><a class="anchor" href="#aoikwinwhich-d"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-D</h2><pre><code>//
module aoikwinwhich;

import std.algorithm: any;
import std.algorithm: endsWith;
import std.algorithm: map;
import std.algorithm: filter;
import std.array : appender;
import std.array : array;
import std.array : join;
import std.array : split;
import std.file : FileException;
import std.file : isFile;
import std.path : buildPath;
import std.path : pathSeparator;
import std.process: env = environment;
import std.stdio : writeln;
import std.string : toLower;

//
bool contain(string[] item_s, string item) {
    foreach (_item; item_s) {
        if (_item == item) {
            return true;
        }
    }
    return false;
}

string[] uniq(string[] item_s) {
    auto item_s_new = appender!(string[]);

    foreach (item; item_s) {
        if (!contain(item_s_new.data, item)) {
            item_s_new.put(item);
        }
    }

    return item_s_new.data;
}

bool file_exists(string path) {
    auto path_is_file = false;

    try {
        path_is_file = path.isFile();
    } catch (FileException) {}

    return path_is_file;
}

string[] find_executable(string prog) {
    // 8f1kRCu
    auto env_var_PATHEXT = env.get(`PATHEXT`);
    /// can be &quot;&quot;

    // 6qhHTHF
    // split into a list of extensions
    auto ext_s = (env_var_PATHEXT == &quot;&quot;)
        ? []
        : env_var_PATHEXT.split(pathSeparator);

    // 2pGJrMW
    // strip
    ext_s = array(ext_s.map!(x =&gt; x));

    // 2gqeHHl
    // remove empty
    ext_s = array(ext_s.filter!(x =&gt; x != &quot;&quot;));

    // 2zdGM8W
    // convert to lowercase
    ext_s = array(ext_s.map!(x =&gt; x.toLower()));

    // 2fT8aRB
    // uniquify
    ext_s = uniq(ext_s);

    // 4ysaQVN
    auto env_var_PATH = env.get(`PATH`);
    /// can be &quot;&quot;

    // 6mPI0lg
    auto dir_path_s = (env_var_PATH == &quot;&quot;)
        ? []
        : env_var_PATH.split(pathSeparator);

    // 5rT49zI
    // insert empty dir path to the beginning
    //
    // Empty dir handles the case that |prog| is a path, either relative or
    //  absolute. See code 7rO7NIN.
    dir_path_s = [&quot;&quot;] ~ dir_path_s;

    // 2klTv20
    // uniquify
    dir_path_s = uniq(dir_path_s);

    //
    auto prog_lower = prog.toLower();

    auto prog_has_ext = ext_s.any!(x =&gt; prog_lower.endsWith(x));

    // 6bFwhbv
    auto exe_path_s = appender!(string[]);

    foreach (dir_path; dir_path_s) {
        // 7rO7NIN
        // synthesize a path with the dir and prog
        auto path = (dir_path == &quot;&quot;)
            ? prog
            : buildPath(dir_path, prog);

        // 6kZa5cq
        // assume the path has extension, check if it is an executable
        if (prog_has_ext &amp;&amp; file_exists(path)) {
            exe_path_s.put(path);
        }

        // 2sJhhEV
        // assume the path has no extension
        foreach (ext; ext_s) {
            // 6k9X6GP
            // synthesize a new path with the path and the executable extension
            auto path_plus_ext = path ~ ext;

            // 6kabzQg
            // check if it is an executable
            if (file_exists(path_plus_ext)) {
                exe_path_s.put(path_plus_ext);
            }
        }
    }

    // 8swW6Av
    // uniquify
    auto exe_path_s_uniq = uniq(exe_path_s.data);

    //
    return exe_path_s_uniq;
}

void main(string[] args)
{
    // 9mlJlKg
    // check if one cmd arg is given
    if (args.length != 2) {
        // 7rOUXFo
        // print program usage
        writeln(`Usage: aoikwinwhich PROG`);
        writeln(``);
        writeln(`#/ PROG can be either name or path`);
        writeln(`aoikwinwhich notepad.exe`);
        writeln(`aoikwinwhich C:\Windows\notepad.exe`);
        writeln(``);
        writeln(`#/ PROG can be either absolute or relative`);
        writeln(`aoikwinwhich C:\Windows\notepad.exe`);
        writeln(`aoikwinwhich Windows\notepad.exe`);
        writeln(``);
        writeln(`#/ PROG can be either with or without extension`);
        writeln(`aoikwinwhich notepad.exe`);
        writeln(`aoikwinwhich notepad`);
        writeln(`aoikwinwhich C:\Windows\notepad.exe`);
        writeln(`aoikwinwhich C:\Windows\notepad`);

        // 3nqHnP7
        return;
    }

    // 9m5B08H
    // get name or path of a program from cmd arg
    auto prog = args[1];


    // 8ulvPXM
    // find executables
    auto path_s = find_executable(prog);

    // 5fWrcaF
    // has found none, exit
    if (path_s.length == 0) {
        // 3uswpx0
        return;
    }

    // 9xPCWuS
    // has found some, output
    auto txt = array(path_s).join(&quot;\n&quot;);

    writeln(txt);

    // 4s1yY1b
    return;
}</code></pre><h2 id="aoikwinwhich-dart"><a class="anchor" href="#aoikwinwhich-dart"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Dart</h2><pre><code>//
import &#39;dart:io&#39; show File;
import &#39;dart:io&#39; show Platform;

//
List&lt;String&gt; list_uniq(List item_s) {
    var item_s_uniq = [];

    for (var item in item_s) {
        if (!item_s_uniq.contains(item)) {
            item_s_uniq.add(item);
        }
    }

    return item_s_uniq;
}

List&lt;String&gt; find_executable(String prog) {
    // 8f1kRCu
    var env_var_PATHEXT = Platform.environment[&#39;PATHEXT&#39;];
    /// can be null

    // 6qhHTHF
    // split into a list of extensions
    var sep = &#39;;&#39;;

    var ext_s = (env_var_PATHEXT == null) ? [] : env_var_PATHEXT.split(sep);

    // 2pGJrMW
    // strip
    ext_s = ext_s.map((x) =&gt; x.trim());
    /// result is iterable

    // 2gqeHHl
    // remove empty
    ext_s = ext_s.where((x) =&gt; x != &#39;&#39;);
    /// result is iterable

    // 2zdGM8W
    // convert to lowercase
    ext_s = ext_s.map((x) =&gt; x.toLowerCase());
    /// result is iterable

    // 2fT8aRB
    // uniquify
    ext_s = list_uniq(ext_s);
    /// result is list

    // 4ysaQVN
    var env_var_PATH = Platform.environment[&#39;PATH&#39;];
    /// can be null

    // 6mPI0lg
    var dir_path_s = (env_var_PATH == null) ? [] : env_var_PATH.split(sep);

    // 5rT49zI
    // insert empty dir path to the beginning
    //
    // Empty dir handles the case that |prog| is a path, either relative or
    //  absolute. See code 7rO7NIN.
    dir_path_s.insert(0, &#39;&#39;);

    // 2klTv20
    // uniquify
    dir_path_s = list_uniq(dir_path_s);

    //
    var prog_has_ext = ext_s.any((x) =&gt; prog.endsWith(x));

    // 6bFwhbv
    var exe_path_s = [];

    for (var dir_path in dir_path_s) {
        // 7rO7NIN
        // synthesize a path with the dir and prog
        var path = (dir_path == &#39;&#39;)
            ? prog
            : dir_path + &#39;\\&#39; + prog;

        // 6kZa5cq
        // assume the path has extension, check if it is an executable
        if (prog_has_ext &amp;&amp; new File(path).existsSync()) {
            exe_path_s.add(path);
        }

        // 2sJhhEV
        // assume the path has no extension
        for (var ext in ext_s) {
            // 6k9X6GP
            // synthesize a new path with the path and the executable extension
            var path_plus_ext = path + ext;

            // 6kabzQg
            // check if it is an executable
            if (new File(path_plus_ext).existsSync()) {
                exe_path_s.add(path_plus_ext);
            }
        }
    }

    // 8swW6Av
    // uniquify
    exe_path_s = list_uniq(exe_path_s);

    //
    return exe_path_s;
}

void main(List&lt;String&gt; args) {
    // 9mlJlKg
    if (args.length != 1) {
        // 7rOUXFo
        // print program usage
        print(r&#39;Usage: aoikwinwhich PROG&#39;);
        print(&#39;&#39;);
        print(r&#39;#/ PROG can be either name or path&#39;);
        print(r&#39;aoikwinwhich notepad.exe&#39;);
        print(r&#39;aoikwinwhich C:\Windows\notepad.exe&#39;);
        print(&#39;&#39;);
        print(r&#39;#/ PROG can be either absolute or relative&#39;);
        print(r&#39;aoikwinwhich C:\Windows\notepad.exe&#39;);
        print(r&#39;aoikwinwhich Windows\notepad.exe&#39;);
        print(&#39;&#39;);
        print(r&#39;#/ PROG can be either with or without extension&#39;);
        print(r&#39;aoikwinwhich notepad.exe&#39;);
        print(r&#39;aoikwinwhich notepad&#39;);
        print(r&#39;aoikwinwhich C:\Windows\notepad.exe&#39;);
        print(r&#39;aoikwinwhich C:\Windows\notepad&#39;);

        // 3nqHnP7
        return;
    }

    // 9m5B08H
    // get name or path of a program from cmd arg
    var prog = args[0];

    // 8ulvPXM
    // find executables
    var path_s = find_executable(prog);

    // 5fWrcaF
    // has found none, exit
    if (path_s.length == 0) {
        // 3uswpx0
        return;
    }

    // 9xPCWuS
    // has found some, output
    var txt = path_s.reduce((a, b) =&gt; a + &#39;\n&#39; + b);

    print(txt);

    // 4s1yY1b
    return;
}</code></pre><h2 id="aoikwinwhich-eiffel"><a class="anchor" href="#aoikwinwhich-eiffel"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Eiffel</h2><pre><code>    --
class
    AOIKWINWHICH

create
    make

feature {NONE} -- Create

    make
        local
            exc: EXCEPTIONS
        do
            create exc
            exc.die (main)
        end

feature {NONE} -- Main

        -- 4zKrqsC
        -- Program entry

    main: INTEGER
        local
            args: ARGUMENTS_32
            prog: STRING_32
            exe_path_s: LIST [STRING_32]
        do
                --
            create args

                -- 9mlJlKg
                -- If not exactly one command argument is given
            if args.argument_count /~ 1 then
                    -- 7rOUXFo
                    -- Print program usage
                print (&quot;[
Usage: aoikwinwhich PROG

#/ PROG can be either name or path
aoikwinwhich notepad.exe
aoikwinwhich C:\Windows\notepad.exe

#/ PROG can be either absolute or relative
aoikwinwhich C:\Windows\notepad.exe
aoikwinwhich Windows\notepad.exe

#/ PROG can be either with or without extension
aoikwinwhich notepad.exe
aoikwinwhich notepad
aoikwinwhich C:\Windows\notepad.exe
aoikwinwhich C:\Windows\notepad

]&quot;)

                    -- 3nqHnP7
                    -- Exit
                RESULT := 1
            else

                    -- 9m5B08H
                    -- Get executable name or path
                prog := args.argument (1)

                    -- 8ulvPXM
                    -- Find executable paths
                exe_path_s := find_exe_paths (prog)

                    -- 5fWrcaF
                    -- If has found none
                if exe_path_s.count = 0 then
                        -- 3uswpx0
                        -- Exit
                    RESULT := 2
                else
                        -- If has found some

                        -- 9xPCWuS
                        -- Print result
                    across
                        exe_path_s as exe_path_i
                    loop
                        print (exe_path_i.item + &quot;%N&quot;)
                    end

                        -- 4s1yY1b
                        -- Exit
                    RESULT := 0
                end
            end
        end

feature {NONE}

        --

    proc_lc: STRING_32
            -- &quot;lc&quot; means lowercase.
            -- Initialized at 6pyGU6b, used at 2t8XU4N.
            -- Eiffel&#39;s agent function can not access function arguments and local variables,
            -- so have to use an instance field.

        --

    find_exe_paths (prog: STRING_32): LIST [STRING_32]
        local
            env: EXECUTION_ENVIRONMENT
            env_pathext: detachable STRING_32
            env_path: detachable STRING_32
            ext_s: LIST [STRING_32]
            dir_path_s: LINKED_LIST [STRING_32]
            prog_has_ext: BOOLEAN
            exe_path_s: LINKED_LIST [STRING_32]
            path: STRING_32
            path_2: STRING_32
            file: PLAIN_TEXT_FILE
        do

                --
            create env

                -- 6pyGU6b
            proc_lc := prog.as_lower

                -- 8f1kRCu
            env_pathext := env.item (&quot;PATHEXT&quot;)

                -- 4fpQ2RB
            if env_pathext = Void then
                    -- 9dqlPRg
                    -- Return
                Result := create {LINKED_LIST [STRING_32]}.make
            else

                    -- 6qhHTHF
                    -- Split into a list of extensions
                ext_s := env_pathext.split (&#39;;&#39;)

                    -- 2pGJrMW
                    -- Strip
                across
                    ext_s as ext_i
                loop
                        -- Mutate the string
                    ext_i.item.left_adjust
                    ext_i.item.right_adjust
                end

                    -- 2gqeHHl
                    -- Remove empty.
                    -- Must be done after the stripping at 2pGJrMW.
                ext_s := list_filter (ext_s, (agent  (ext: STRING_32): BOOLEAN
                    do
                        Result := ext /= &quot;&quot;
                    end))

                    -- 2zdGM8W
                    -- Convert to lowercase
                ext_s.do_all ((agent  (ext: STRING_32)
                    do
                            -- Mutate the string
                        ext.to_lower
                    end))

                    -- 2fT8aRB
                    -- Uniquify
                ext_s := list_uniq (ext_s)

                    -- 4ysaQVN
                env_path := env.item (&quot;PATH&quot;)

                    -- 5gGwKZL
                if env_path = Void then
                        -- 7bVmOKe
                        -- Go ahead with &quot;dir_path_s&quot; being empty
                    dir_path_s := create {LINKED_LIST [STRING_32]}.make
                else

                        -- 6mPI0lg
                        -- Split into a list of dir paths
                    dir_path_s := list_to_linked_list (env_path.split (&#39;;&#39;))
                end

                    -- 5rT49zI
                    -- Insert empty dir path to the beginning.
                    --
                    -- Empty dir handles the case that &quot;prog&quot; is not a short name,
                    -- either relative or absolute. See code 7rO7NIN.
                dir_path_s.start
                dir_path_s.put_left (&quot;&quot;)

                    -- 2klTv20
                    -- Uniquify
                dir_path_s := list_uniq (dir_path_s)

                    -- 9gTU1rI
                    -- Check if &quot;prog&quot; ends with one of the file extension in &quot;ext_s&quot;.
                prog_has_ext := ext_s.there_exists ((agent  (ext: STRING_32): BOOLEAN
                    do
                            -- 2t8XU4N
                        Result := proc_lc.ends_with (ext)
                    end))

                    -- 6bFwhbv
                create exe_path_s.make
                across
                    dir_path_s as dir_path_i
                loop
                        -- 7rO7NIN
                        -- Synthesize a path
                    if dir_path_i.item.is_equal (&quot;&quot;) then
                        path := prog
                    else
                        path := dir_path_i.item + &quot;\&quot; + prog
                    end

                        --
                    create file.make_with_name (path)

                        -- 6kZa5cq
                        -- If &quot;prog&quot; ends with executable file extension
                    if prog_has_ext then
                            -- 3whKebE
                        if file.access_exists then
                                -- 2ffmxRF
                            exe_path_s.finish
                            exe_path_s.put_right (path)
                        end
                    end

                        -- 2sJhhEV
                        -- Assume user has omitted the file extension
                    across
                        ext_s as ext_i
                    loop
                            -- 6k9X6GP
                            -- Synthesize a path with one of the file extensions in PATHEXT
                        path_2 := path + ext_i.item
                        create file.make_with_name (path_2)

                            -- 6kabzQg
                        if file.access_exists then
                                -- 7dui4cD
                            exe_path_s.finish
                            exe_path_s.put_right (path_2)
                        end
                    end
                end

                    -- 8swW6Av
                    -- Uniquify
                exe_path_s := list_uniq (exe_path_s)

                    -- 7y3JlnS
                Result := exe_path_s
            end
        end

feature {NONE} -- List util

        --

    list_filter (item_s: LIST [STRING_32]; predicate: FUNCTION [ANY, TUPLE [STRING_32], BOOLEAN]): LIST [STRING_32]
        local
            res: LINKED_LIST [STRING_32]
        do
                --
            create res.make

                --
            across
                item_s as i
            loop
                if predicate.item (i.item) then
                    res.finish
                    res.put_right (i.item)
                end
            end

                --
            Result := res
        end

        --

    list_has_item (item_s: LIST [STRING_32]; item: STRING_32): BOOLEAN
            -- Comparison is by value equality using &quot;STRING_32.is_equal&quot;.
        do
            from
                RESULT := false
                item_s.start
            until
                item_s.exhausted
            loop
                if item_s.item.is_equal (item) then
                    RESULT := true
                    item_s.finish
                end
                item_s.forth
            end
        end

        --

    list_uniq (item_s: LIST [STRING_32]): LINKED_LIST [STRING_32]
        local
            item_s_uniq: LINKED_LIST [STRING_32]
        do
                --
            create item_s_uniq.make

                --
            across
                item_s as item_i
            loop
                    -- `item_s_uniq.has(cur.item)` not works
                if not list_has_item (item_s_uniq, item_i.item) then
                    item_s_uniq.finish
                    item_s_uniq.put_right (item_i.item)
                end
            end

                --
            Result := item_s_uniq
        end

        --

    list_to_linked_list (item_s: LIST [STRING_32]): LINKED_LIST [STRING_32]
        do
                --
            create Result.make

                --
            across
                item_s as item_i
            loop
                Result.finish
                Result.put_right (item_i.item)
            end
        end

end</code></pre><h2 id="aoikwinwhich-erlang"><a class="anchor" href="#aoikwinwhich-erlang"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Erlang</h2><pre><code>%%

uniq(Item_s) -&gt;
    lists:foldl(
        fun(Item, Acc) -&gt;
            ItemExists = lists:member(Item, Acc),
            if ItemExists -&gt;
                Acc
            ;true -&gt;
                lists:append(Acc, [Item])
            end
        end, [], Item_s).

find_executale(Prog) -&gt;
    %% 8f1kRCu
    EnvPATHENV = os:getenv(&quot;PATHEXT&quot;),
    %%% can be false

    %% 6qhHTHF
    %% split into a list of extensions
    Ext_s =
        if EnvPATHENV == false -&gt;
            []
        ;true -&gt;
            string:tokens(EnvPATHENV, &quot;;&quot;)
        end,

    %% 2pGJrMW
    %% strip
    Ext_s2 = lists:map(fun(X) -&gt; string:strip(X) end, Ext_s),

    %% 2gqeHHl
    %% remove empty
    Ext_s3 = lists:filter(fun(X) -&gt; X =/= &quot;&quot; end, Ext_s2),

    %% 2zdGM8W
    %% convert to lowercase
    Ext_s4 = lists:map(fun(X) -&gt; string:to_lower(X) end, Ext_s3),

    %% 2fT8aRB
    %% uniquify
    Ext_s5 = gb_sets:to_list(gb_sets:from_list(Ext_s4)),

    %% 4ysaQVN
    EnvPATH = os:getenv(&quot;PATH&quot;),
    %%% can be false

    %% 6mPI0lg
    Dir_s =
        if EnvPATH == false -&gt;
            []
        ;true -&gt;
            string:tokens(EnvPATH, &quot;;&quot;)
        end,

    %% 5rT49zI
    %% insert empty dir path to the beginning
    %%
    %% Empty dir handles the case that |prog| is a path, either relative or
    %%  absolute. See code 7rO7NIN.
    Dir_s2 = [&quot;&quot; | Dir_s],

    %% 2klTv20
    %% uniquify
    Dir_s3 = uniq(Dir_s2),

    %%
    ProgLc = string:to_lower(Prog),

    ProgHasExt = lists:any(fun(Ext) -&gt; lists:suffix(Ext, ProgLc) end, Ext_s5),

    %% 6bFwhbv
    Exe_path_s_res = lists:foldl(
        fun(Dir, Acc) -&gt;
            %% 7rO7NIN
            %% synthesize a path with the dir and prog
            Path =
                if Dir == &quot;&quot; -&gt;
                    Prog
                ;true -&gt;
                    string:join([Dir, &quot;\\&quot; ,Prog], &quot;&quot;)
                end,

            %% 6kZa5cq
            %% assume the path has extension, check if it is an executable
            PathExists = filelib:is_regular(Path),

            if ProgHasExt andalso PathExists -&gt;
                Exe_path_s = [Path]
            ;true -&gt;
                Exe_path_s = []
            end,

            %% 2sJhhEV
            %% assume the path has no extension
            Exe_path_s2 = [
                %% 6k9X6GP
                %% synthesize a new path with the path and the executable extension
                string:concat(Path, Ext) ||
                Ext &lt;- Ext_s5,
                %% 6kabzQg
                %% check if it is an executable
                filelib:is_regular(string:concat(Path, Ext))
            ],

            %% New Acc result
            lists:append([Acc, Exe_path_s, Exe_path_s2])

        end, [], Dir_s3),

    %% 8swW6Av
    %% uniquify
    Exe_path_s_res2 = uniq(Exe_path_s_res),

    %%
    Exe_path_s_res2.

println(Str) -&gt;
    io:format(&quot;~s~n&quot;, [Str]).

main(Args) -&gt;
    %% 9mlJlKg
    if length(Args) =/= 1 -&gt;
        %% 7rOUXFo
        %% print program usage
        println(&quot;Usage: aoikwinwhich PROG&quot;),
        println(&quot;&quot;),
        println(&quot;#/ PROG can be either name or path&quot;),
        println(&quot;aoikwinwhich notepad.exe&quot;),
        println(&quot;aoikwinwhich C:\\Windows\\notepad.exe&quot;),
        println(&quot;&quot;),
        println(&quot;#/ PROG can be either absolute or relative&quot;),
        println(&quot;aoikwinwhich C:\\Windows\\notepad.exe&quot;),
        println(&quot;aoikwinwhich Windows\\notepad.exe&quot;),
        println(&quot;&quot;),
        println(&quot;#/ PROG can be either with or without extension&quot;),
        println(&quot;aoikwinwhich notepad.exe&quot;),
        println(&quot;aoikwinwhich notepad&quot;),
        println(&quot;aoikwinwhich C:\\Windows\\notepad.exe&quot;),
        println(&quot;aoikwinwhich C:\\Windows\\notepad&quot;),

        %% 3nqHnP7
        noop
    ;true -&gt;
        %% 9m5B08H
        %% get name or path of a program from cmd arg
        Prog = lists:nth(1, Args),

        %% 8ulvPXM
        %% find executables
        Path_s = find_executale(Prog),

        %% 5fWrcaF
        %% has found none, exit
        if length(Path_s) == 0 -&gt;
            %% 3uswpx0
            noop
        ;true -&gt;
            %% 9xPCWuS
            %% has found some, output
            Txt = string:join(Path_s, &quot;\n&quot;),

            println(Txt),

            %% 4s1yY1b
            noop
        end
    end.</code></pre><h2 id="aoikwinwhich-fsharp"><a class="anchor" href="#aoikwinwhich-fsharp"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-FSharp</h2><pre><code>//
namespace AoikWinWhich

type Console = System.Console
type Environment = System.Environment
type File = System.IO.File
type Path = System.IO.Path
type String = System.String

//
module AoikWinWhich =

    let find_executable (prog:string) =
        // 8f1kRCu
        let env_var_PATHEXT = Environment.GetEnvironmentVariable(&quot;PATHEXT&quot;)
        /// can be null

        // 6qhHTHF
        // split into a list of extensions
        let ext_s =
            if env_var_PATHEXT = null then
                []
            else
                env_var_PATHEXT.Split(Path.PathSeparator) |&gt; Array.toList

        // 2pGJrMW
        // strip
        let ext_s = ext_s |&gt; List.map (fun x -&gt; x.Trim())

        // 2gqeHHl
        // remove empty
        let ext_s = ext_s |&gt; List.filter (fun x -&gt; x &lt;&gt; &quot;&quot;)

        // 2zdGM8W
        // convert to lowercase
        let ext_s = ext_s |&gt; List.map (fun x -&gt; x.ToLower())

        // 2fT8aRB
        // uniquify
        let ext_s = ext_s |&gt; Seq.distinct |&gt; Seq.toList

        // 4ysaQVN
        let env_var_PATH = Environment.GetEnvironmentVariable(&quot;PATH&quot;)
        /// can be null

        let dir_path_s =
            if env_var_PATH = null then
                []
            else
                env_var_PATH.Split(Path.PathSeparator) |&gt; Array.toList

        // 5rT49zI
        // insert empty dir path to the beginning
        //
        // Empty dir handles the case that |prog| is a path, either relative or
        //  absolute. See code 7rO7NIN.
        let dir_path_s = &quot;&quot; :: dir_path_s

        // 2klTv20
        // uniquify
        let dir_path_s = dir_path_s |&gt; Seq.distinct |&gt; Seq.toList

        //
        let prog_lc = prog.ToLower()

        let prog_has_ext = ext_s |&gt; List.exists (fun ext -&gt; prog_lc.EndsWith(ext))

        // 6bFwhbv
        let mutable exe_path_s = []

        for dir_path in dir_path_s do
            // 7rO7NIN
            // synthesize a path with the dir and prog
            let path =
                if dir_path = &quot;&quot; then
                    prog
                else
                    Path.Combine(dir_path, prog)

            // 6kZa5cq
            // assume the path has extension, check if it is an executable
            if prog_has_ext &amp;&amp; File.Exists(path) then
                exe_path_s &lt;- path :: exe_path_s
                ()

            // 2sJhhEV
            // assume the path has no extension
            for ext in ext_s do
                // 6k9X6GP
                // synthesize a new path with the path and the executable extension
                let path_plus_ext = path + ext

                // 6kabzQg
                // check if it is an executable
                if File.Exists(path_plus_ext) then
                    exe_path_s &lt;- path_plus_ext :: exe_path_s
                    ()

        // reverse
        let exe_path_s = exe_path_s |&gt; List.rev

        // 8swW6Av
        // uniquify
        let exe_path_s = exe_path_s |&gt; Seq.distinct |&gt; Seq.toList

        // return
        exe_path_s

    [&lt;EntryPoint&gt;]
    let main args =
        // 9mlJlKg
        let args_len = Array.length args

        if args_len &lt;&gt; 1 then
            // 7rOUXFo
            // print program usage
            Console.WriteLine(@&quot;Usage: aoikwinwhich PROG&quot;)
            Console.WriteLine(@&quot;&quot;)
            Console.WriteLine(@&quot;#/ PROG can be either name or path&quot;)
            Console.WriteLine(@&quot;aoikwinwhich notepad.exe&quot;)
            Console.WriteLine(@&quot;aoikwinwhich C:\Windows\notepad.exe&quot;)
            Console.WriteLine(@&quot;&quot;)
            Console.WriteLine(@&quot;#/ PROG can be either absolute or relative&quot;)
            Console.WriteLine(@&quot;aoikwinwhich C:\Windows\notepad.exe&quot;)
            Console.WriteLine(@&quot;aoikwinwhich Windows\notepad.exe&quot;)
            Console.WriteLine(@&quot;&quot;)
            Console.WriteLine(@&quot;#/ PROG can be either with or without extension&quot;)
            Console.WriteLine(@&quot;aoikwinwhich notepad.exe&quot;)
            Console.WriteLine(@&quot;aoikwinwhich notepad&quot;)
            Console.WriteLine(@&quot;aoikwinwhich C:\Windows\notepad.exe&quot;)
            Console.WriteLine(@&quot;aoikwinwhich C:\Windows\notepad&quot;)

            // 3nqHnP7
            2
        else
            // 9m5B08H
            // get name or path of a program from cmd arg
            let prog = args.[0]

            // 8ulvPXM
            // find executables
            let path_s = find_executable(prog)

            //
            if path_s.Length = 0 then
                // 5fWrcaF
                // has found none, exit

                // 3uswpx0
                1
            else
                // 9xPCWuS
                // has found some, output
                let txt = String.Join(&quot;\n&quot;, path_s)

                Console.WriteLine(txt)

                // 4s1yY1b
                0</code></pre><h2 id="aoikwinwhich-go"><a class="anchor" href="#aoikwinwhich-go"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Go</h2><pre><code>package main

import &quot;fmt&quot;
import &quot;os&quot;
import &quot;strings&quot;

type strtostr func(string) string

type strtobool func(string) bool

func mapto(item_s []string, f strtostr) []string {
    item_s_new := []string{}

    for _, item := range item_s {
        item_new := f(item)
        item_s_new = append(item_s_new, item_new)
    }

    return item_s_new
}

func filter(item_s []string, f strtobool) []string {
    item_s_new := []string{}

    for _, item := range item_s {
        if f(item) {
            item_s_new = append(item_s_new, item)
        }
    }

    return item_s_new
}

func any(item_s []string, f strtobool) bool {
    for _, item := range item_s {
        if f(item) {
            return true
        }
    }

    return false
}

func contain(item_s []string, item string) bool {
    for _, x := range item_s {
        if x == item {
            return true
        }
    }
    return false
}

func append_uniq(item_s []string, item string) []string {
    if contain(item_s, item) {
        return item_s
    } else {
        return append(item_s, item)
    }
}

func uniq(item_s []string) []string {
    item_s_new := []string{}

    for _, item := range item_s {
        item_s_new = append_uniq(item_s_new, item)
    }

    return item_s_new;
}

// Modified from |http://stackoverflow.com/a/12527546|.
// ---BEG
func file_exists(path string) bool {
    _, err := os.Stat(path)

    if err != nil {
        if os.IsNotExist(err) {
            return false
        }
    }

    return true
}
// ---END

func find_executable(prog string) []string {
    // 8f1kRCu
    env_var_PATHEXT := os.Getenv(&quot;PATHEXT&quot;)
    /// can be &quot;&quot;

    // 6qhHTHF
    // split into a list of extensions
    val_sep := string(os.PathListSeparator)

    var ext_s []string = nil

    if env_var_PATHEXT == &quot;&quot; {
        ext_s = []string{}
    } else {
        ext_s = strings.Split(env_var_PATHEXT, val_sep)
    }

    // 2pGJrMW
    // strip
    ext_s = mapto(ext_s, func(x string) string {
        return strings.TrimSpace(x)
    })

    // 2gqeHHl
    // remove empty
    ext_s = filter(ext_s, func(x string) bool {
        return x != &quot;&quot;
    })

    // 2zdGM8W
    // convert to lowercase
    ext_s = mapto(ext_s, func(x string) string {
        return strings.ToLower(x)
    })

    // 2fT8aRB
    // uniquify
    ext_s = uniq(ext_s);

    // 4ysaQVN
    env_var_PATH := os.Getenv(&quot;PATH&quot;)
    /// can be &quot;&quot;

    // 6mPI0lg
    var dir_path_s []string = nil

    if env_var_PATH == &quot;&quot; {
        dir_path_s = []string{}
    } else {
        dir_path_s = strings.Split(env_var_PATH, val_sep)
    }

    // 5rT49zI
    // insert empty dir path to the beginning
    //
    // Empty dir handles the case that |prog| is a path, either relative or
    //  absolute. See code 7rO7NIN.
    dir_path_s = append([]string{&quot;&quot;}, dir_path_s...)

    // 2klTv20
    // uniquify
    dir_path_s = uniq(dir_path_s)

    //
    prog_lower := strings.ToLower(prog)

    prog_has_ext := any(ext_s, func(x string) bool {
        return strings.HasSuffix(prog_lower, x)
    })

    // 6bFwhbv
    path_sep := string(os.PathSeparator)

    exe_path_s := []string{}

    for _, dir_path := range dir_path_s {
        // 7rO7NIN
        // synthesize a path with the dir and prog
        path := &quot;&quot;

        if dir_path == &quot;&quot; {
            path = prog
        } else {
            path = dir_path + path_sep + prog
        }

        // 6kZa5cq
        // assume the path has extension, check if it is an executable
        if prog_has_ext &amp;&amp; file_exists(path) {
            exe_path_s = append(exe_path_s, path)
        }

        // 2sJhhEV
        // assume the path has no extension
        for _, ext := range ext_s {
            // 6k9X6GP
            // synthesize a new path with the path and the executable extension
            path_plus_ext := path + ext

            // 6kabzQg
            // check if it is an executable
            if file_exists(path_plus_ext) {
                exe_path_s = append(exe_path_s, path_plus_ext)
            }
        }
    }

    // 8swW6Av
    // uniquify
    exe_path_s = uniq(exe_path_s);

    //
    return exe_path_s
}

func main() {
    //
    println := fmt.Println

    // 9mlJlKg
    // check if one cmd arg is given
    args := os.Args[1:]

    if (len(args) != 1) {
        // 7rOUXFo
        // print program usage
        println(`Usage: aoikwinwhich PROG`);
        println(``);
        println(`#/ PROG can be either name or path`);
        println(`aoikwinwhich notepad.exe`);
        println(`aoikwinwhich C:\Windows\notepad.exe`);
        println(``);
        println(`#/ PROG can be either absolute or relative`);
        println(`aoikwinwhich C:\Windows\notepad.exe`);
        println(`aoikwinwhich Windows\notepad.exe`);
        println(``);
        println(`#/ PROG can be either with or without extension`);
        println(`aoikwinwhich notepad.exe`);
        println(`aoikwinwhich notepad`);
        println(`aoikwinwhich C:\Windows\notepad.exe`);
        println(`aoikwinwhich C:\Windows\notepad`);

        // 3nqHnP7
        return;
    }

    // 9m5B08H
    // get name or path of a program from cmd arg
    prog := args[0]

    // 8ulvPXM
    // find executables
    path_s := find_executable(prog);

    // 5fWrcaF
    // has found none, exit
    if (len(path_s) == 0) {
        // 3uswpx0
        return;
    }

    // 9xPCWuS
    // has found some, output
    txt := strings.Join(path_s, &quot;\n&quot;)

    println(txt)

    // 4s1yY1b
    return;
}</code></pre><h2 id="aoikwinwhich-groovy"><a class="anchor" href="#aoikwinwhich-groovy"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Groovy</h2><pre><code>//
package aoikwinwhich
import java.io.File
import java.nio.file.Files
import java.nio.file.Paths

def find_executable(prog) {
    // 8f1kRCu
    def env_var_PATHEXT = System.getenv(&quot;PATHEXT&quot;)
    /// can be null

    // 6qhHTHF
    // split into a list of extensions
    def ext_s = (env_var_PATHEXT == null) ? [] :
        env_var_PATHEXT.split(File.pathSeparator).toList()

    // 2pGJrMW
    // strip
    ext_s = ext_s.collect({it.trim()})

    // 2gqeHHl
    // remove empty
    ext_s = ext_s.grep({!it.equals(&quot;&quot;)})

    // 2zdGM8W
    // convert to lowercase
    ext_s = ext_s.collect({it.toLowerCase()})

    // 2fT8aRB
    // uniquify
    ext_s.unique()

    // 4ysaQVN
    def env_var_PATH = System.getenv(&quot;PATH&quot;)
    /// can be null

    // 6mPI0lg
    def dir_path_s = (env_var_PATH == null) ? [] :
        env_var_PATH.split(File.pathSeparator).toList()

    // 5rT49zI
    // insert empty dir path to the beginning
    //
    // Empty dir handles the case that |prog| is a path, either relative or
    //  absolute. See code 7rO7NIN.
    dir_path_s.add(0, &quot;&quot;)

    // 2klTv20
    // uniquify
    dir_path_s.unique()
    /// LinkedHashSet keeps the original order.

    // 6bFwhbv
    def exe_path_s = []

    for (dir_path in dir_path_s) {
        // 7rO7NIN
        // synthesize a path with the dir and prog
        def path = dir_path.equals(&quot;&quot;) ? prog :
            Paths.get(dir_path, prog).toString()

        // 6kZa5cq
        // assume the path has extension, check if it is an executable
        if (ext_s.any({path.endsWith(it)})) {
            if (Files.isRegularFile(Paths.get(path))) {
                exe_path_s.add(path)
            }
        }

        // 2sJhhEV
        // assume the path has no extension
        for (ext in ext_s) {
            // 6k9X6GP
            // synthesize a new path with the path and the executable extension
            def path_plus_ext = path + ext

            // 6kabzQg
            // check if it is an executable
            if (Files.isRegularFile(Paths.get(path_plus_ext))) {
                exe_path_s.add(path_plus_ext)
            }
        }
    }

    //
    return exe_path_s
}

def main2(args) {
    // 9mlJlKg
    // check if one cmd arg is given
    if (args.length != 1) {
        // 7rOUXFo
        // print program usage
        println(/Usage: aoikwinwhich PROG/)
        println(&quot;&quot;)
        println(/#\/ PROG can be either name or path/)
        println(/aoikwinwhich notepad.exe/)
        println(/aoikwinwhich C:\Windows\notepad.exe/)
        println(&quot;&quot;)
        println(/#\/ PROG can be either absolute or relative/)
        println(/aoikwinwhich C:\Windows\notepad.exe/)
        println(/aoikwinwhich Windows\\notepad.exe/)
        println(&quot;&quot;)
        println(/#\/ PROG can be either with or without extension/)
        println(/aoikwinwhich notepad.exe/)
        println(/aoikwinwhich notepad/)
        println(/aoikwinwhich C:\Windows\notepad.exe/)
        println(/aoikwinwhich C:\Windows\notepad/)

        // 3nqHnP7
        return
    }

    // 9m5B08H
    // get name or path of a program from cmd arg
    def prog = args[0]

    // 8ulvPXM
    // find executables
    def path_s = find_executable(prog)

    // 5fWrcaF
    // has found none, exit
    if (path_s.size() == 0) {
        // 3uswpx0
        return
    }

    // 9xPCWuS
    // has found some, output
    def txt = path_s.join(&quot;\n&quot;)

    println(txt)

    //
    return
}

//
main2(args)
/// |args| is func arg of the wrapping |main| func auto created by Groovy.</code></pre><h2 id="aoikwinwhich-haskell"><a class="anchor" href="#aoikwinwhich-haskell"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Haskell</h2><pre><code>--
import Control.Monad
import Control.Exception
import System.Directory (doesFileExist)
import System.Environment
import System.Exit
import qualified Data.Text as T
import qualified Data.List as List

--
iff :: Bool -&gt; a -&gt; a -&gt; a
iff True  x _ = x
iff False _ y = y

--
strings_join :: String -&gt; [String] -&gt; String
strings_join delim [] = &quot;&quot;
strings_join delim (x:[]) = x
strings_join delim (x:xs) = x ++ delim ++ (strings_join delim xs)

--
texts_uniq :: [T.Text] -&gt; [T.Text]
texts_uniq [] = []
texts_uniq (x:xs) =
    let xs_uniq = (texts_uniq xs)
    in
    iff (x `elem` xs_uniq)
        (xs_uniq)
        ([x] ++ xs_uniq)

--
getEnvOrEmpty :: String -&gt; IO String
getEnvOrEmpty name =
    getEnv name `catch`
        -- &quot;(e :: IOException)&quot; is for hinting exception type
        (\e -&gt; let _ = (e :: IOException) in return &quot;&quot;)

--
find_exe_paths :: String -&gt; IO [String]
find_exe_paths prog =
    do
        -- 8f1kRCu
        env_pathext &lt;- getEnvOrEmpty &quot;PATHEXT&quot;

        -- 4fpQ2RB
        iff (env_pathext == &quot;&quot;)
            -- then
            -- 9dqlPRg
            (return [])
            -- else
            (do
                -- 6qhHTHF
                -- Split into a list of extensions
                let ext_s = T.splitOn (T.pack &quot;;&quot;) (T.pack env_pathext)

                -- 2pGJrMW
                -- Strip
                let ext_s_2 = map T.strip ext_s

                -- 2gqeHHl
                -- Remove empty
                let ext_s_3 = filter (\x -&gt; x /= (T.pack &quot;&quot;)) ext_s_2

                -- 2zdGM8W
                -- Convert to lowercase
                let ext_s_4 = map T.toLower ext_s_3

                -- 2fT8aRB
                -- Uniquify
                let ext_s_5 = texts_uniq ext_s_4

                -- 4ysaQVN
                env_path &lt;- getEnvOrEmpty &quot;PATH&quot;

                -- 5gGwKZL
                let dir_path_s = iff (env_path == &quot;&quot;)
                                    -- then
                                    -- 7bVmOKe
                                    -- Go ahead with &quot;dir_path_s&quot; being empty
                                    []
                                    -- else
                                    -- 6mPI0lg
                                    -- Split into a list of paths
                                    (T.splitOn (T.pack &quot;;&quot;) (T.pack env_path))

                -- 5rT49zI
                -- Insert empty dir path to the beginning.
                --
                -- Empty dir handles the case that &quot;prog&quot; is a path, either
                -- relative or absolute. See code 7rO7NIN.
                let dir_path_s2 = [T.pack &quot;&quot;] ++ dir_path_s

                -- 2klTv20
                -- Uniquify
                let dir_path_s3 = texts_uniq dir_path_s2

                -- 9gTU1rI
                -- Check if &quot;prog&quot; ends with one of the file extension in
                -- &quot;ext_s_5&quot;.
                --
                -- &quot;ext_s_5&quot; are all in lowercase, ensured at 2zdGM8W.
                let prog_lc = T.toLower (T.pack prog)

                let prog_has_ext = any (`T.isSuffixOf` prog_lc) ext_s_5

                -- 6bFwhbv
                exe_path_s &lt;- liftM List.concat (
                    (`mapM` dir_path_s3) (\dir_path -&gt; do
                        -- 7rO7NIN
                        -- Synthesize a path
                        let path = iff (dir_path == T.pack &quot;&quot;)
                                        (T.pack prog)
                                        (T.concat [
                                                    dir_path
                                                    ,(T.pack &quot;\\&quot;)
                                                    ,(T.pack prog)
                                                    ])

                        -- &quot;exe_path&quot; is used at 4bm0d25.
                        -- Its value being empty string means file not exist.
                        exe_path &lt;-
                            -- 6kZa5cq
                            -- If &quot;prog&quot; ends with executable file extension
                            iff prog_has_ext
                            -- then
                            (do
                                file_exists &lt;- (doesFileExist (T.unpack path))

                                -- 3whKebE
                                iff file_exists
                                    -- then
                                    -- 2ffmxRF
                                    (return path)
                                    -- else
                                    (return (T.pack &quot;&quot;))
                            )
                            -- else
                            (return (T.pack &quot;&quot;))

                        -- 2sJhhEV
                        -- Assume user has omitted the file extension
                        exe_path_s &lt;- liftM List.concat (
                            (`mapM` ext_s_5) (\ext -&gt; do
                                -- 6k9X6GP
                                -- Synthesize a path with one of the file
                                -- extensions in PATHEXT
                                let path_2 = (T.concat [path, ext])

                                file_exists_2 &lt;-
                                    (doesFileExist (T.unpack path_2))

                                -- 6kabzQg
                                iff file_exists_2
                                    -- then
                                    -- 7dui4cD
                                    (return [path_2])
                                    -- else
                                    (return [])
                                )
                            )

                        -- 4bm0d25
                        iff (exe_path == (T.pack &quot;&quot;))
                            -- then
                            (return exe_path_s)
                            -- then
                            (return ([exe_path] ++ exe_path_s))

                        --
                        )
                    )

                -- 8swW6Av
                -- Uniquify
                let exe_path_s2 = texts_uniq exe_path_s

                -- Convert from Text to String
                let exe_path_s3 = map T.unpack exe_path_s2

                -- 7y3JlnS
                return exe_path_s3
            )

-- 4zKrqsC
-- Program entry
main = do
    --
    arg_s &lt;- getArgs

    --
    let arg_cnt = length arg_s

    -- 9mlJlKg
    -- If not exactly one command argument is given
    iff (arg_cnt /= 1)
        -- then
        (do
            -- 7rOUXFo
            -- Print program usage
            let usage = strings_join &quot;\n&quot; [
                            &quot;Usage: aoikwinwhich PROG&quot;,
                            &quot;&quot;,
                            &quot;#/ PROG can be either name or path&quot;,
                            &quot;aoikwinwhich notepad.exe&quot;,
                            &quot;aoikwinwhich C:\\Windows\\notepad.exe&quot;,
                            &quot;&quot;,
                            &quot;#/ PROG can be either absolute or relative&quot;,
                            &quot;aoikwinwhich C:\\Windows\\notepad.exe&quot;,
                            &quot;aoikwinwhich Windows\\notepad.exe&quot;,
                            &quot;&quot;,
                            &quot;#/ PROG can be either with or without extension&quot;,
                            &quot;aoikwinwhich notepad.exe&quot;,
                            &quot;aoikwinwhich notepad&quot;,
                            &quot;aoikwinwhich C:\\Windows\\notepad.exe&quot;,
                            &quot;aoikwinwhich C:\\Windows\\notepad\n&quot;
                            ]

            putStr usage

            -- 3nqHnP7
            exitWith (ExitFailure 1)
        )
        -- else
        (do
            -- 9m5B08H
            -- Get executable name or path
            let prog = head arg_s

            -- 8ulvPXM
            -- Find executable paths
            exe_path_s &lt;- find_exe_paths prog

            -- 5fWrcaF
            -- If has found none
            iff (length exe_path_s == 0)
                -- then
                (do
                    -- 3uswpx0
                    exitWith (ExitFailure 2)
                )
                -- else
                -- If has found some
                (do
                    -- 9xPCWuS
                    -- Print to stdout
                    putStrLn (strings_join &quot;\n&quot; exe_path_s)

                    -- 4s1yY1b
                    exitWith (ExitSuccess)
                )
        )</code></pre><h2 id="aoikwinwhich-hy"><a class="anchor" href="#aoikwinwhich-hy"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Hy</h2><pre><code>;
(import os)
(import os.path)

;
(defn list_uniq [item_s]
    ;
    (setv item_s_uniq [])

    (for [item item_s]
        (if (not (in item item_s_uniq))
            ; then
            (item_s_uniq.append item)
            ; else
            None
        )
    )

    ; Return
    item_s_uniq
)

;
(defn find_exe_paths [prog]
    ; 8f1kRCu
    (setv env_pathext (os.environ.get &quot;PATHEXT&quot; None))

    ; 4fpQ2RB
    (if (not env_pathext)
        ; then
        ; Return
        []
        ; else
        (do
            ; 6qhHTHF
            ; Split into a list of extensions
            (setv ext_s (env_pathext.split os.pathsep))

            ; 2pGJrMW
            ; Strip
            (setv ext_s (list-comp (x.strip) [x ext_s]))

            ; 2gqeHHl
            ; Remove empty.
            ; Must be done after the stripping at 2pGJrMW.
            (setv ext_s (list-comp x [x ext_s] (!= x &quot;&quot;)))

            ; 2zdGM8W
            ; Convert to lowercase
            (setv ext_s (list-comp (x.lower) [x ext_s]))

            ; 2fT8aRB
            ; Uniquify
            (setv ext_s (list_uniq ext_s))

            ; 4ysaQVN
            (setv env_path (os.environ.get &quot;PATH&quot; None))

            ;
            (setv dir_path_s
                ; 5gGwKZL
                (if (not env_path)
                    ; then
                    ; 7bVmOKe
                    ; Go ahead with &quot;dir_path_s&quot; being empty
                    []
                    ; else
                    ; 6mPI0lg
                    ; Split into a list of dir paths
                    (env_path.split os.pathsep)
                )
            )

            ; 5rT49zI
            ; Insert empty dir path to the beginning
            ;
            ; Empty dir handles the case that &quot;prog&quot; is a path, either
            ; relative or absolute. See code 7rO7NIN.
            (dir_path_s.insert 0 &quot;&quot;)

            ; 2klTv20
            ; Uniquify
            (setv dir_path_s (list_uniq dir_path_s))

            ; 9gTU1rI
            ; Check if &quot;prog&quot; ends with one of the file extension in
            ; &quot;ext_s&quot;.
            ;
            ; &quot;ext_s&quot; are all in lowercase, ensured at 2zdGM8W.
            (setv prog_lc (prog.lower))

            (setv prog_has_ext (prog_lc.endswith (tuple ext_s)))
            ; &quot;endswith&quot; requires tuple, not list.

            ; 6bFwhbv
            (setv exe_path_s [])

            (for [dir_path dir_path_s]
                (do
                    ; 7rO7NIN
                    ; Synthesize a path
                    (setv path
                        (if (= dir_path &quot;&quot;)
                            ; then
                            prog
                            ; else
                            (os.path.join dir_path prog)
                        )
                    )

                    ; 6kZa5cq
                    ; If &quot;prog&quot; ends with executable file extension
                    (if prog_has_ext
                        ; then
                        ; 3whKebE
                        (if (os.path.isfile path)
                            ; then
                            ; 2ffmxRF
                            (exe_path_s.append path)
                            ; else
                            None
                        )
                        ; else
                        None
                    )

                    ; 2sJhhEV
                    ; Assume user has omitted the file extension
                    (for [ext ext_s]
                        (do
                            ; 6k9X6GP
                            ; Synthesize a path with one of the file extensions
                            ; in PATHEXT
                            (setv path_2 (+ path ext))

                            ; 6kabzQg
                            (if (os.path.isfile path_2)
                                ; then
                                ; 7dui4cD
                                (exe_path_s.append path_2)
                                ; else
                                None
                            )
                        )
                    )
                )
            )

            ; 8swW6Av
            ; Uniquify
            (setv exe_path_s (list_uniq exe_path_s))

            ; 7y3JlnS
            ; Return
            exe_path_s
        )
    )
)

; 4zKrqsC
; Program entry
(defmain [&amp;rest args]
    ; 9mlJlKg
    ; If not exactly one command argument is given
    (if (!= (len args) 2)
        ; then
        (do
            ; 7rOUXFo
            ; Print program usage
            (print r&quot;Usage: aoikwinwhich PROG

#/ PROG can be either name or path
aoikwinwhich notepad.exe
aoikwinwhich C:\Windows\notepad.exe

#/ PROG can be either absolute or relative
aoikwinwhich C:\Windows\notepad.exe
aoikwinwhich Windows\notepad.exe

#/ PROG can be either with or without extension
aoikwinwhich notepad.exe
aoikwinwhich notepad
aoikwinwhich C:\Windows\notepad.exe
aoikwinwhich C:\Windows\notepad&quot;)

            ; 3nqHnP7
            ; Exit
            ;
            ; Hy 0.11.0 on Windows prints &quot;defmain&quot;&#39;s return value, instead of
            ; setting the return value as exit code. So we return None here to
            ; avoid the printing.
            None
        )
        ; else
        (do
            ; 9m5B08H
            ; Get executable name or path
            (setv prog (. args[1]))

            ; 8ulvPXM
            ; Find executable paths
            (setv exe_path_s (find_exe_paths prog))

            ; 5fWrcaF
            ; If has found none
            (if (not exe_path_s)
                ; then
                ; Exit
                None
                ; else
                ; If has found some
                ;
                (do
                    ; 9xPCWuS
                    ; Print result
                    (print ((. &quot;\n&quot; join) exe_path_s))

                    ; 4s1yY1b
                    ; Exit
                    None
                )
            )
        )
    )
)</code></pre><h2 id="aoikwinwhich-java"><a class="anchor" href="#aoikwinwhich-java"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Java</h2><pre><code>//
package aoikwinwhich;
import static java.lang.System.out;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.stream.Collectors;

public class AoikWinWhich {

    public static List&lt;String&gt; find_executable(String prog) {
        // 8f1kRCu
        String env_var_PATHEXT = System.getenv(&quot;PATHEXT&quot;);
        /// can be null

        // 6qhHTHF
        // split into a list of extensions
        List&lt;String&gt; ext_s = (env_var_PATHEXT == null)
            ? new LinkedList&lt;&gt;()
            : Arrays.asList(env_var_PATHEXT.split(File.pathSeparator));

        // 2pGJrMW
        // strip
        ext_s = ext_s.stream().map(String::trim).collect(Collectors.toList());

        // 2gqeHHl
        // remove empty
        ext_s = ext_s.stream().filter(x -&gt; !x.equals(&quot;&quot;)).collect(Collectors.toList());

        // 2zdGM8W
        // convert to lowercase
        ext_s = ext_s.stream().map(String::toLowerCase).collect(Collectors.toList());

        // 2fT8aRB
        // uniquify
        ext_s = new LinkedList&lt;&gt;(new LinkedHashSet&lt;&gt;(ext_s));
        /// LinkedHashSet keeps the original order.

        // 4ysaQVN
        String env_var_PATH = System.getenv(&quot;PATH&quot;);
        /// can be null

        // 6mPI0lg
        List&lt;String&gt; dir_path_s = (env_var_PATH == null)
            ? new LinkedList&lt;&gt;()
            : new LinkedList&lt;&gt;(Arrays.asList(env_var_PATH.split(File.pathSeparator)));

        // 5rT49zI
        // insert empty dir path to the beginning
        //
        // Empty dir handles the case that |prog| is a path, either relative or
        //  absolute. See code 7rO7NIN.
        dir_path_s.add(0, &quot;&quot;);

        // 2klTv20
        // uniquify
        dir_path_s = new LinkedList&lt;&gt;(new LinkedHashSet&lt;&gt;(dir_path_s));
        /// LinkedHashSet keeps the original order.

        // 6bFwhbv
        List&lt;String&gt; exe_path_s = new LinkedList&lt;&gt;();

        for (String dir_path : dir_path_s) {
            // 7rO7NIN
            // synthesize a path with the dir and prog
            final String path = dir_path.equals(&quot;&quot;) ? prog :
                                Paths.get(dir_path, prog).toString();
            /// |final| is needed for |path| to be used in the lambda below.

            // 6kZa5cq
            // assume the path has extension, check if it is an executable
            if (ext_s.parallelStream().anyMatch(ext -&gt; path.endsWith(ext))) {
                if (Files.isRegularFile(Paths.get(path))) {
                    exe_path_s.add(path);
                }
            }

            // 2sJhhEV
            // assume the path has no extension
            for (String ext : ext_s) {
                // 6k9X6GP
                // synthesize a new path with the path and the executable extension
                String path_plus_ext = path + ext;

                // 6kabzQg
                // check if it is an executable
                if (Files.isRegularFile(Paths.get(path_plus_ext))) {
                    exe_path_s.add(path_plus_ext);
                }
            }
        }

        //
        return exe_path_s;
    }

    public static void main(String[] args) {
        // 9mlJlKg
        // check if one cmd arg is given
        if (args.length != 1) {
            // 7rOUXFo
            // print program usage
            out.println(&quot;Usage: aoikwinwhich PROG&quot;);
            out.println(&quot;&quot;);
            out.println(&quot;#/ PROG can be either name or path&quot;);
            out.println(&quot;aoikwinwhich notepad.exe&quot;);
            out.println(&quot;aoikwinwhich C:\\Windows\\notepad.exe&quot;);
            out.println(&quot;&quot;);
            out.println(&quot;#/ PROG can be either absolute or relative&quot;);
            out.println(&quot;aoikwinwhich C:\\Windows\\notepad.exe&quot;);
            out.println(&quot;aoikwinwhich Windows\\notepad.exe&quot;);
            out.println(&quot;&quot;);
            out.println(&quot;#/ PROG can be either with or without extension&quot;);
            out.println(&quot;aoikwinwhich notepad.exe&quot;);
            out.println(&quot;aoikwinwhich notepad&quot;);
            out.println(&quot;aoikwinwhich C:\\Windows\\notepad.exe&quot;);
            out.println(&quot;aoikwinwhich C:\\Windows\\notepad&quot;);

            // 3nqHnP7
            return;
        }

        // 9m5B08H
        // get name or path of a program from cmd arg
        String prog = args[0];

        // 8ulvPXM
        // find executables
        List&lt;String&gt; path_s = find_executable(prog);

        // 5fWrcaF
        // has found none, exit
        if (path_s.size() == 0) {
            // 3uswpx0
            return;
        }

        // 9xPCWuS
        // has found some, output
        String txt = String.join(&quot;\n&quot;, path_s);

        out.println(txt);

        //
        return;
    }
}</code></pre><h2 id="aoikwinwhich-javascript"><a class="anchor" href="#aoikwinwhich-javascript"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-JavaScript</h2><pre><code>//
&#39;use strict&#39;;

//
var _fs = require(&#39;fs&#39;);
var _path = require(&#39;path&#39;);
var _ = require(&#39;underscore&#39;);

// add func |endsWith| to String
if (typeof String.prototype.endsWith !== &#39;function&#39;) {
    String.prototype.endsWith = function (suffix) {
        return this.indexOf(suffix, this.length - suffix.length) !== -1;
    };
}

function is_file(path) {
    var fstat = null;
    try {
        fstat = _fs.statSync(path);
    } catch (err) {
        return false;
    }
    return fstat &amp;&amp; fstat.isFile();
}

function find_executable(prog) {
    // 8f1kRCu
    var env_var_PATHEXT = process.env.PATHEXT;
    /// can be |undefined|

    // 6qhHTHF
    // split into a list of extensions
    var ext_s = !env_var_PATHEXT ? [] : env_var_PATHEXT.split(_path.delimiter);

    // 2pGJrMW
    // strip
    ext_s = _.map(ext_s, function (ext) {
        return ext.trim();
    });

    // 2gqeHHl
    // remove empty
    ext_s = _.filter(ext_s, function (ext) {
        return ext !== &#39;&#39;;
    });

    // 2zdGM8W
    // convert to lowercase
    ext_s = _.map(ext_s, function (ext) {
        return ext.toLowerCase();
    });

    // 2fT8aRB
    // uniquify
    ext_s = _.uniq(ext_s);

    // 4ysaQVN
    var env_var_PATH = process.env.PATH;
    /// can be |undefined|
    ///
    /// if has value, there is an ending |;| in it,
    ///  which results in an ending empty string for the splitting at 3zVznlK

    // 6mPI0lg
    var dir_path_s = !env_var_PATH ? [] : env_var_PATH.split(_path.delimiter);
    /// 3zVznlK

    // 5rT49zI
    // insert empty dir path to the beginning
    //
    // Empty dir handles the case that |prog| is a path, either relative or absolute.
    // See code 7rO7NIN.
    dir_path_s.unshift(&#39;&#39;);

    // 2klTv20
    // uniquify
    dir_path_s = _.uniq(dir_path_s);

    // 6bFwhbv
    var exe_path_s = [];
    _.each(dir_path_s, function (dir_path) {
        // 7rO7NIN
        // synthesize a path with the dir and prog
        var path = _path.join(dir_path, prog);

        // 6kZa5cq
        // assume the path has extension, check if it is an executable
        if (_.any(ext_s, function (ext) {
            return path.endsWith(ext);
        })) {
            if (is_file(path)) {
                exe_path_s.push(path);
            }
        }

        // 2sJhhEV
        // assume the path has no extension
        _.each(ext_s, function (ext) {
            // 6k9X6GP
            // synthesize a new path with the path and the executable extension
            var path_plus_ext = path + ext;
            // 6kabzQg
            // check if it is an executable
            if (is_file(path_plus_ext)) {
                exe_path_s.push(path_plus_ext);
            }
        });
    });

    // 8swW6Av
    // uniquify
    exe_path_s = _.uniq(exe_path_s);

    //
    return exe_path_s;
}

function print(txt) {
    process.stdout.write(txt + &#39;\n&#39;);
}

function main() {
    // 9mlJlKg
    // check if one cmd arg is given
    var arg_s = process.argv.slice(2);

    if (arg_s.length != 1) {
        // 7rOUXFo
        // print program usage
        print(&#39;Usage: aoikwinwhich PROG&#39;);
        print(&#39;&#39;);
        print(&#39;#/ PROG can be either name or path&#39;);
        print(&#39;aoikwinwhich notepad.exe&#39;);
        print(&#39;aoikwinwhich C:\\Windows\\notepad.exe&#39;);
        print(&#39;&#39;);
        print(&#39;#/ PROG can be either absolute or relative&#39;);
        print(&#39;aoikwinwhich C:\\Windows\\notepad.exe&#39;);
        print(&#39;aoikwinwhich Windows\\notepad.exe&#39;);
        print(&#39;&#39;);
        print(&#39;#/ PROG can be either with or without extension&#39;);
        print(&#39;aoikwinwhich notepad.exe&#39;);
        print(&#39;aoikwinwhich notepad&#39;);
        print(&#39;aoikwinwhich C:\\Windows\\notepad.exe&#39;);
        print(&#39;aoikwinwhich C:\\Windows\\notepad&#39;);

        // 3nqHnP7
        return;
    }

    // 9m5B08H
    // get name or path of a program from cmd arg
    var prog = arg_s[0];

    // 8ulvPXM
    // find executables
    var path_s = find_executable(prog);

    // 5fWrcaF
    // has found none, exit
    if (!path_s.length) {
        // 3uswpx0
        return;
    }

    // 9xPCWuS
    // has found some, output
    var txt = path_s.join(&#39;\n&#39;);

    print(txt);

    // 4s1yY1b
    return;
}

//
exports.main = main;

//
if (require.main == module) {
    main();
}</code></pre><h2 id="aoikwinwhich-julia"><a class="anchor" href="#aoikwinwhich-julia"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Julia</h2><pre><code>#
function find_exe_paths(prog)
    # 8f1kRCu
    env_pathext = get(ENV, &quot;PATHEXT&quot;, &quot;&quot;)

    # 4fpQ2RB
    if env_pathext == &quot;&quot;
        # 9dqlPRg
        return []
    end

    # 6qhHTHF
    # Split into a list of extensions
    ext_s = split(env_pathext, &quot;;&quot;)


    # 2pGJrMW
    # Strip
    ext_s = [strip(ext) for ext=ext_s]

    # 2gqeHHl
    # Remove empty.
    # Must be done after the stripping at 2pGJrMW.
    ext_s = filter(x -&gt; x != &quot;&quot;, ext_s)

    # 2zdGM8W
    # Convert to lowercase
    ext_s = [lowercase(ext) for ext=ext_s]

    # 2fT8aRB
    # Uniquify
    ext_s = unique(ext_s)

    # 4ysaQVN
    env_path = get(ENV, &quot;PATH&quot;, &quot;&quot;)

    # 5gGwKZL
    if env_path == &quot;&quot;
        # 7bVmOKe
        # Go ahead with &quot;dir_path_s&quot; being empty
        dir_path_s = []
    else
        # 6mPI0lg
        # Split into a list of dir paths
        dir_path_s = split(env_path, &quot;;&quot;)
    end

    # 5rT49zI
    # Insert empty dir path to the beginning.
    #
    # Empty dir handles the case that &quot;prog&quot; is a path, either relative or
    # absolute. See code 7rO7NIN.
    unshift!(dir_path_s, &quot;&quot;)

    # 2klTv20
    # Uniquify
    dir_path_s = unique(dir_path_s)

    # 9gTU1rI
    # Check if &quot;prog&quot; ends with one of the file extension in &quot;ext_s&quot;.
    #
    # &quot;ext_s&quot; are all in lowercase, ensured at 2zdGM8W.
    prog_lc = lowercase(prog)

    prog_has_ext = (findfirst(ext -&gt; endswith(prog_lc, ext), ext_s)) != 0
    # Index value &quot;0&quot; means not found.

    # 6bFwhbv
    exe_path_s = String[]

    for dir_path=dir_path_s
        # 7rO7NIN
        # Synthesize a path
        if dir_path == &quot;&quot;
            path = prog
        else
            path = dir_path * &quot;\\&quot; *  prog
        end

        # 6kZa5cq
        # If &quot;prog&quot; ends with executable file extension
        if prog_has_ext
            # 3whKebE
            if isfile(path)
                # 2ffmxRF
                push!(exe_path_s, path)
            end
        end

        # 2sJhhEV
        # Assume user has omitted the file extension
        for ext=ext_s
            # 6k9X6GP
            # Synthesize a path with one of the file extensions in PATHEXT
            path_2 = path * ext

            # 6kabzQg
            if isfile(path_2)
                # 7dui4cD
                push!(exe_path_s, path_2)
            end
        end
    end

    # 8swW6Av
    # Uniquify
    exe_path_s = unique(exe_path_s)

    # 7y3JlnS
    return exe_path_s
end

#
function main()
    # 9mlJlKg
    # If not exactly one command argument is given
    if length(ARGS) != 1
        usage = &quot;&quot;&quot;Usage: aoikwinwhich PROG

#/ PROG can be either name or path
aoikwinwhich notepad.exe
aoikwinwhich C:\\Windows\\notepad.exe

#/ PROG can be either absolute or relative
aoikwinwhich C:\\Windows\\notepad.exe
aoikwinwhich Windows\\notepad.exe

#/ PROG can be either with or without extension
aoikwinwhich notepad.exe
aoikwinwhich notepad
aoikwinwhich C:\\Windows\\notepad.exe
aoikwinwhich C:\\Windows\\notepad&quot;&quot;&quot;

        # 7rOUXFo
        # Print program usage
        print(usage)

        # 3nqHnP7
        # Exit
        return 1
    end

    # 9m5B08H
    # Get executable name or path
    prog = ARGS[1]

    # 8ulvPXM
    # Find executable paths
    exe_path_s = find_exe_paths(prog)


    # 5fWrcaF
    # If has found none
    if length(exe_path_s) == 0
        # 3uswpx0
        # Exit
        return 2
    # If has found some
    else
        # 9xPCWuS
        # Print result
        print(join(exe_path_s, &quot;\n&quot;) * &quot;\n&quot;)

        # 4s1yY1b
        # Exit
        return 0
    end
end

# 4zKrqsC
# Program entry
exit(main())</code></pre><h2 id="aoikwinwhich-kotlin"><a class="anchor" href="#aoikwinwhich-kotlin"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Kotlin</h2><pre><code>//
package aoikwinwhich

import java.io.File
import java.nio.file.Files
import java.nio.file.Paths
import java.util.LinkedHashSet
import java.util.LinkedList

//
object AoikWinWhich {

    fun find_executable(prog: String): List&lt;String&gt; {
        // 8f1kRCu
        val env_var_PATHEXT = System.getenv(&quot;PATHEXT&quot;)
        /// can be null

        // 6qhHTHF
        // split into a list of extensions
        var ext_s =
            if (env_var_PATHEXT == null)
                listOf&lt;String&gt;()
            else
                env_var_PATHEXT.split(File.pathSeparator).toList()

        // 2pGJrMW
        // strip
        ext_s = ext_s.map({x -&gt; x.trim()})

        // 2gqeHHl
        // remove empty
        ext_s = ext_s.filter({x -&gt; x != &quot;&quot;})

        // 2zdGM8W
        // convert to lowercase
        ext_s = ext_s.map({x -&gt; x.toLowerCase()})

        // 2fT8aRB
        // uniquify
        ext_s = LinkedHashSet(ext_s).toList()
        /// LinkedHashSet keeps the original order.

        // 4ysaQVN
        val env_var_PATH = System.getenv(&quot;PATH&quot;)
        /// can be null

        // 6mPI0lg
        var dir_path_s =
            if (env_var_PATH == null)
                linkedListOf&lt;String&gt;()
            else
                env_var_PATH.split(File.pathSeparator).toLinkedList()

        // 5rT49zI
        // insert empty dir path to the beginning
        //
        // Empty dir handles the case that |prog| is a path, either relative or
        //  absolute. See code 7rO7NIN.
        dir_path_s.add(0, &quot;&quot;)

        // 2klTv20
        // uniquify
        dir_path_s = LinkedHashSet(dir_path_s).toLinkedList()
        /// LinkedHashSet keeps the original order.

        //
        val prog_lc = prog.toLowerCase()

        val prog_has_ext = ext_s.any({ext -&gt; prog_lc.endsWith(ext)})

        // 6bFwhbv
        var exe_path_s = linkedListOf&lt;String&gt;()

        for (dir_path in dir_path_s) {
            // 7rO7NIN
            // synthesize a path with the dir and prog
            val path =
                if (dir_path == &quot;&quot;)
                    prog
                else
                    Paths.get(dir_path, prog).toString()

            // 6kZa5cq
            // assume the path has extension, check if it is an executable
            if (prog_has_ext &amp;&amp; Files.isRegularFile(Paths.get(path))) {
                 exe_path_s.add(path)
            }

            // 2sJhhEV
            // assume the path has no extension
            for (ext in ext_s) {
                // 6k9X6GP
                // synthesize a new path with the path and the executable extension
                val path_plus_ext = path + ext

                // 6kabzQg
                // check if it is an executable
                if (Files.isRegularFile(Paths.get(path_plus_ext))) {
                    exe_path_s.add(path_plus_ext)
                }
            }
        }

        // 8swW6Av
        // uniquify
        exe_path_s = LinkedHashSet(exe_path_s).toLinkedList()
        /// LinkedHashSet keeps the original order.

        //
        return exe_path_s
    }

    fun main(args: Array&lt;String&gt;) {
        // 9mlJlKg
        // check if one cmd arg is given
        if (args.size != 1) {
            // 7rOUXFo
            // print program usage
            println(&quot;&quot;&quot;Usage: aoikwinwhich PROG&quot;&quot;&quot;)
            println()
            println(&quot;&quot;&quot;#/ PROG can be either name or path&quot;&quot;&quot;)
            println(&quot;&quot;&quot;aoikwinwhich notepad.exe&quot;&quot;&quot;)
            println(&quot;&quot;&quot;aoikwinwhich C:\Windows\notepad.exe&quot;&quot;&quot;)
            println(&quot;&quot;)
            println(&quot;&quot;&quot;#/ PROG can be either absolute or relative&quot;&quot;&quot;)
            println(&quot;&quot;&quot;aoikwinwhich C:\Windows\notepad.exe&quot;&quot;&quot;)
            println(&quot;&quot;&quot;aoikwinwhich Windows\notepad.exe&quot;&quot;&quot;)
            println(&quot;&quot;)
            println(&quot;&quot;&quot;#/ PROG can be either with or without extension&quot;&quot;&quot;)
            println(&quot;&quot;&quot;aoikwinwhich notepad.exe&quot;&quot;&quot;)
            println(&quot;&quot;&quot;aoikwinwhich notepad&quot;&quot;&quot;)
            println(&quot;&quot;&quot;aoikwinwhich C:\Windows\notepad.exe&quot;&quot;&quot;)
            println(&quot;&quot;&quot;aoikwinwhich C:\Windows\notepad&quot;&quot;&quot;)

            // 3nqHnP7
            return
        }

        // 9m5B08H
        // get name or path of a program from cmd arg
        val prog = args[0]

        // 8ulvPXM
        // find executables
        val path_s = find_executable(prog)

        // 5fWrcaF
        // has found none, exit
        if (path_s.size == 0) {
            // 3uswpx0
            return
        }

        // 9xPCWuS
        // has found some, output
        val txt = path_s.join(&quot;\n&quot;)

        println(txt)

        // 4s1yY1b
        return
    }
}

//
fun main(args: Array&lt;String&gt;) {
    AoikWinWhich.main(args)
}</code></pre><h2 id="aoikwinwhich-lua"><a class="anchor" href="#aoikwinwhich-lua"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Lua</h2><pre><code>--

-- Copied from |http://lua-users.org/wiki/SplitJoin|.
-- Renamed from |explode| to |string.split|.
-- BEG
function string.split(p,d)
  local t, ll
  t={}
  ll=0
  if(#p == 1) then return {p} end
    while true do
      l=string.find(p,d,ll,true) -- find the next d in the string
      if l~=nil then -- if &quot;not not&quot; found then..
        table.insert(t, string.sub(p,ll,l-1)) -- Save it in our array.
        ll=l+1 -- save just after where we found it for searching next time.
      else
        table.insert(t, string.sub(p,ll)) -- Save what&#39;s left in our array.
        break -- Break at end, as it should be, according to the lua manual.
      end
    end
  return t
end
-- END

-- Copied from |http://lua-users.org/wiki/StringTrim|.
-- Renamed from |trim12| to |string.trim|.
-- BEG
function string.trim(s)
 local from = s:match&quot;^%s*()&quot;
 return from &gt; #s and &quot;&quot; or s:match(&quot;.*%S&quot;, from)
end
-- END

-- Copied from |http://lua-users.org/wiki/StringRecipes|.
-- Renamed from |string.ends| to |string.endswith|.
-- BEG
function string.endswith(String,End)
   return End==&#39;&#39; or string.sub(String,-string.len(End))==End
end
-- END

function map(item_s, func)
    local item_s_new = {}

    for key, val in ipairs(item_s) do
        item_s_new[key] = func(val)
    end

    return item_s_new
end

function filter(item_s, func)
    local item_s_new = {}

    local ord = 0

    for key, val in ipairs(item_s) do
        if func(val) then
            ord = ord + 1
            item_s_new[ord] = val
        end
    end

    return item_s_new
end

function any(item_s, func)
    for key, val in ipairs(item_s) do
        if func(val) then
            return true
        end
    end

    return false
end

function uniq(item_s)
    --
    local val_ord_s = {}

    local ord_val_s_uniq = {}

    --
    local ord = 1

    for _, val in ipairs(item_s) do
        --
        val_exists = val_ord_s[val]
        --- can be nil

        if (not val_exists) then
            val_ord_s[val] = ord

            ord_val_s_uniq[ord] = val

            ord = ord + 1
        end
    end

    table.sort(ord_val_s_uniq, function (va, vb) return val_ord_s[va] &lt; val_ord_s[vb] end)

    return ord_val_s_uniq
end

-- Copied from |http://stackoverflow.com/a/4991602|.
-- Choose not to add dependency on |lfs|
--  (http://keplerproject.github.io/luafilesystem/) so use a simple func that
--  only checks if the file is openable, not sure if it is regular file.
-- BEG
function file_exists(name)
   local f=io.open(name,&quot;r&quot;)
   if f~=nil then io.close(f) return true else return false end
end
-- END

function find_executable(prog)
    -- 8f1kRCu
    local env_var_PATHEXT = os.getenv(&#39;PATHEXT&#39;)
    --- can be null

    -- 6qhHTHF
    -- split into a list of extensions
    local sep = &#39;;&#39;

    local ext_s = (not env_var_PATHEXT) and {} or env_var_PATHEXT:split(sep)

    -- 2pGJrMW
    -- strip
    ext_s = map(ext_s, function(x) return x:trim() end)

    -- 2gqeHHl
    -- remove empty
    ext_s = filter(ext_s, function(x) return x ~= &#39;&#39; end)

    -- 2zdGM8W
    -- convert to lowercase
    ext_s = map(ext_s, function(x) return x:lower() end)

    -- 2fT8aRB
    -- uniquify
    ext_s = uniq(ext_s)

    -- 4ysaQVN
    env_var_PATH = os.getenv(&#39;PATH&#39;)
    --- can be nil

    -- 6mPI0lg
    local dir_path_s = (not env_var_PATH) and {} or env_var_PATH:split(sep)

    -- 5rT49zI
    -- insert empty dir path to the beginning
    --
    -- Empty dir handles the case that |prog| is a path, either relative or
    --  absolute. See code 7rO7NIN.
    table.insert(dir_path_s, 1, &#39;&#39;)

    -- 2klTv20
    -- uniquify
    dir_path_s = uniq(dir_path_s)

    --
    local prog_has_ext = any(ext_s, function(x) return prog:lower():endswith(x) end)

    -- 6bFwhbv
    exe_path_s = {}

    for _, dir_path in ipairs(dir_path_s) do
        -- 7rO7NIN
        -- synthesize a path with the dir and prog
        path = (dir_path == &#39;&#39;) and prog or dir_path .. &#39;\\&#39; .. prog

        -- 6kZa5cq
        -- assume the path has extension, check if it is an executable
        if prog_has_ext and file_exists(path) then
            exe_path_s[#exe_path_s+1] = path
        end

        -- 2sJhhEV
        -- assume the path has no extension
        for _, ext in ipairs(ext_s) do
            -- 6k9X6GP
            -- synthesize a new path with the path and the executable extension
            path_plus_ext = path .. ext

            -- 6kabzQg
            -- check if it is an executable
            if file_exists(path_plus_ext) then
                exe_path_s[#exe_path_s+1] = path_plus_ext
            end
        end
    end

    -- 8swW6Av
    -- uniquify
    exe_path_s = uniq(exe_path_s)

    --
    return exe_path_s
end

function main()
    -- 9mlJlKg
    if (#arg ~= 1) then
        -- 7rOUXFo
        -- print program usage
        print([[Usage: aoikwinwhich PROG]])
        print(&#39;&#39;)
        print([[#/ PROG can be either name or path]])
        print([[aoikwinwhich notepad.exe]])
        print([[aoikwinwhich C:\Windows\notepad.exe]])
        print(&#39;&#39;)
        print([[#/ PROG can be either absolute or relative]])
        print([[aoikwinwhich C:\Windows\notepad.exe]])
        print([[aoikwinwhich Windows\notepad.exe]])
        print(&#39;&#39;)
        print([[#/ PROG can be either with or without extension]])
        print([[aoikwinwhich notepad.exe]])
        print([[aoikwinwhich notepad]])
        print([[aoikwinwhich C:\Windows\notepad.exe]])
        print([[aoikwinwhich C:\Windows\notepad]])

        -- 3nqHnP7
        return
    end

    -- 9m5B08H
    -- get name or path of a program from cmd arg
    local prog = arg[1]

    -- 8ulvPXM
    -- find executables
    local path_s = find_executable(prog)

    -- 5fWrcaF
    -- has found none, exit
    if (#path_s == 0) then
        -- 3uswpx0
        return
    end

    -- 9xPCWuS
    -- has found some, output
    local txt = table.concat(path_s, &#39;\n&#39;)

    print(txt)

    -- 4s1yY1b
    return
end

--/
main()</code></pre><h2 id="aoikwinwhich-ocaml"><a class="anchor" href="#aoikwinwhich-ocaml"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-OCaml</h2><pre><code>(**)
#load &quot;str.cma&quot;;;

(**)
let rec list_uniq lst =
    match lst with
    | [] -&gt; []
    | head::tail_s -&gt;
        head :: (list_uniq (List.filter (fun x -&gt; x &lt;&gt; head) tail_s))
;;

(**)
let string_endswith str tail =
    let str_len = String.length(str)  in
    let end_len = String.length(tail) in
    if str_len &lt; end_len then
        false
    else (
        let str_tail = (String.sub str (str_len - end_len) end_len) in
            str_tail = tail
    )
;;

(**)
let find_exe_paths (prog) =
    (* 8f1kRCu *)
    let env_pathext = try Sys.getenv(&quot;PATHEXT&quot;) with Not_found -&gt; &quot;&quot;
    in

    (* 4fpQ2RB *)
    if env_pathext = &quot;&quot; then (
        (* 9dqlPRg *)
        (* Return *)
        []
    )
    else (
        (* 6mPI0lg *)
        (* Split into a list of extensions *)
        let ext_s = (Str.split (Str.regexp &quot;;&quot;) env_pathext)
        in

        (* 2pGJrMW *)
        (* Strip *)
        let ext_s = List.map (String.trim) ext_s
        in

        (* 2zdGM8W *)
        (* Convert to lowercase *)
        let ext_s = List.map (String.lowercase) ext_s
        in

        (* 2gqeHHl *)
        (* Remove empty.
        Must be done after the stripping at 2pGJrMW.
        *)
        let ext_s = List.filter (fun x -&gt; x &lt;&gt; &quot;&quot;) ext_s
        in

        (* 2fT8aRB *)
        (* Uniquify*)
        let ext_s = list_uniq(ext_s)
        in

        (* 4ysaQVN *)
        let env_path = try Sys.getenv(&quot;PATH&quot;) with Not_found -&gt; &quot;&quot;
        in

        (**)
        let dir_path_s =
            (* 5gGwKZL *)
            if env_path = &quot;&quot; then (
                (* 7bVmOKe *)
                (* Go ahead with &quot;dir_path_s&quot; being empty *)
                []
            )
            else
                (* 6mPI0lg *)
                (* Split into a list of dir paths *)
                (Str.split (Str.regexp &quot;;&quot;) env_path)
        in

        (* 5rT49zI*)
        (* Insert empty dir path to the beginning.

        Empty dir handles the case that &quot;prog&quot; is a path, either relative or
        absolute. See code 7rO7NIN.
        *)
        let dir_path_s = (&quot;&quot;)::dir_path_s
        in

        (* 2klTv20 *)
        (* Uniquify *)
        let dir_path_s = list_uniq dir_path_s
        in

        (* Check if &quot;prog&quot; ends with one of the file extension in &quot;ext_s&quot;

        &quot;ext_s&quot; are all in lowercase, ensured at 2zdGM8W.
        *)
        let prog_has_ext =
            let prog_lc = String.lowercase(prog) in
                List.exists
                    (fun ext -&gt; (string_endswith prog_lc ext)) ext_s in

        let exe_path_s = ref [] in

        (* 6bFwhbv *)
        let call_each item_s func = List.iter func item_s in

        begin
        call_each dir_path_s (fun dir_path -&gt;
            (* 7rO7NIN *)
            (* Synthesize a path *)
            let path =
                if dir_path = &quot;&quot; then
                    prog
                else
                    String.concat &quot;&quot; [dir_path; &quot;\\&quot;; prog]
            in

            begin
            (* 6kZa5cq *)
            (* If &quot;prog&quot; ends with executable file extension *)
            if prog_has_ext then
                if Sys.file_exists(path) then
                    (* 2ffmxRF *)
                    exe_path_s := path :: !exe_path_s
            ;

            (* 2sJhhEV *)
            (* Assume user has omitted the file extension *)
            call_each ext_s (fun ext -&gt;
                (* 6k9X6GP *)
                (* Synthesize a path with one of the file extensions in PATHEXT
                *)
                let path_2 = String.concat &quot;&quot; [path; ext]
                in

                (* 6kabzQg *)
                if Sys.file_exists(path_2) then
                    (* 7dui4cD *)
                    exe_path_s := path_2 :: !exe_path_s
                );
            end
        );

        (* 8swW6Av *)
        (* Uniquify *)
        exe_path_s := list_uniq !exe_path_s;

        (* Reverse, due to prepending at 2ffmxRF and 7dui4cD  *)
        exe_path_s := List.rev !exe_path_s;

        (* 7y3JlnS *)
        (* Return *)
        !exe_path_s
        end
    )
;;

(**)
let main () =
    (* 9mlJlKg *)
    (* If not exactly one command argument is given *)
    if Array.length Sys.argv &lt;&gt; 2 then (
        (* 7rOUXFo *)
        (* Print program usage *)
        let usage = &quot;Usage: aoikwinwhich PROG

#/ PROG can be either name or path
aoikwinwhich notepad.exe
aoikwinwhich C:\\Windows\\notepad.exe

#/ PROG can be either absolute or relative
aoikwinwhich C:\\Windows\\notepad.exe
aoikwinwhich Windows\\notepad.exe

#/ PROG can be either with or without extension
aoikwinwhich notepad.exe
aoikwinwhich notepad
aoikwinwhich C:\\Windows\\notepad.exe
aoikwinwhich C:\\Windows\\notepad&quot;
        in
            print_endline(usage);

        (* 3nqHnP7 *)
        (* Exit *)
        1
    )
    else (
        (* 9m5B08H *)
        (* Get executable name or path *)
        let prog = Sys.argv.(1) in

        (* 8ulvPXM *)
        (* Find executable paths *)
        let exe_path_s = find_exe_paths(prog) in

        (* 5fWrcaF *)
        (* If has found none *)
        if List.length(exe_path_s) = 0 then
            (* 3uswpx0 *)
            (* Exit *)
            2
        (* 5fWrcaF *)
        (* If has found none *)
        else (
            (* 9xPCWuS *)
            (* Print result *)
            print_endline(String.concat &quot;\n&quot; exe_path_s);

            (* 4s1yY1b *)
            (* Exit *)
            0
        )
    );
;;

(* 4zKrqsC *)
(* Program entry *)
let () =
    exit(main());
;;</code></pre><h2 id="aoikwinwhich-pascal"><a class="anchor" href="#aoikwinwhich-pascal"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Pascal</h2><pre><code>//
program AoikWinWhich;

uses
  Classes,
  SysUtils,
  strutils;

  function StringSplit(str: string; delim: char): TStringList;
  begin
    Result := TStringList.Create;
    Result.StrictDelimiter := True;
    Result.Delimiter := delim;
    Result.DelimitedText := str;
  end;

  function StringListUniq(item_s: TStringList): TStringList;
  var
    i: integer;
    item: string;
  begin
    Result := TStringList.Create;

    for i := 0 to item_s.Count - 1 do
    begin
      item := item_s[i];

      if Result.IndexOf(item) = -1 then
        Result.add(item);
    end;
  end;

  function FindExePaths(prog: string): TStringList;
  var
    env_pathext: string;
    i: integer;
    ext: string;
    ext_s: TStringList;
    ext_s_2: TStringList;
    env_path: string;
    dir_path: string;
    dir_path_s: TStringList;
    prog_lc: string;
    prog_has_ext: boolean;
    exe_path_s: TStringList;
    path: string;
    path2: string;
  begin
    // 8f1kRCu
    env_pathext := GetEnvironmentVariable(&#39;PATHEXT&#39;);

    // 4fpQ2RB
    if env_pathext = &#39;&#39; then
       // 9dqlPRg
       exit();

    // 6qhHTHF
    // Split into a list of extensions
    ext_s := StringSplit(env_pathext, &#39;;&#39;);

    //
    ext_s_2 := TStringList.Create;

    for i := 0 to ext_s.Count - 1 do
    begin
      ext := ext_s[i];

      // 2pGJrMW
      // Strip
      ext := Trim(ext);

      // 2gqeHHl
      // Remove empty.
      // Must be done after the stripping at 2pGJrMW.
      if ext &lt;&gt; &#39;&#39; then
      begin
        // 2zdGM8W
        // Convert to lowercase
        ext := LowerCase(ext);

        ext_s_2.add(ext);
      end;

      // 2fT8aRB
      // Uniquify
      ext_s_2 := StringListUniq(ext_s_2);

      // 4ysaQVN
      env_path := GetEnvironmentVariable(&#39;PATH&#39;);

      // 5gGwKZL
      if env_path = &#39;&#39; then
        // 7bVmOKe
        // Go ahead with &quot;dir_path_s&quot; being empty
        dir_path_s := TStringList.Create
      else
        // 6mPI0lg
        // Split into a list of paths
        dir_path_s := StringSplit(env_path, &#39;;&#39;);

      // 5rT49zI
      // Insert empty dir path to the beginning.
      //
      // Empty dir handles the case that &quot;prog&quot; is a path, either relative or
      //  absolute. See code 7rO7NIN.
      dir_path_s.Insert(0, &#39;&#39;);

      // 2klTv20
      // Uniquify
      dir_path_s := StringListUniq(dir_path_s);

      // 9gTU1rI
      // Check if &quot;prog&quot; ends with one of the file extension in &quot;ext_s&quot;.
      //
      // &quot;ext_s_2&quot; are all in lowercase, ensured at 2zdGM8W.
      prog_lc := LowerCase(prog);

      prog_has_ext := False;

      for ext in ext_s_2 do
        if AnsiEndsStr(ext, prog_lc) then
        begin
          prog_has_ext := True;

          break;
        end;

      // 6bFwhbv
      exe_path_s := TStringList.Create;

      for dir_path in dir_path_s do
      begin
        // 7rO7NIN
        // Synthesize a path
        if dir_path = &#39;&#39; then
          path := prog
        else
          path := dir_path + &#39;\&#39; + prog;

        // 6kZa5cq
        // If &quot;prog&quot; ends with executable file extension
        if prog_has_ext then
        begin
          // 3whKebE
          if FileExists(path) then
            // 2ffmxRF
            exe_path_s.add(path);
        end;

        // 2sJhhEV
        // Assume user has omitted the file extension
        for ext in ext_s_2 do
        begin
          // 6k9X6GP
          // Synthesize a path with one of the file extensions in PATHEXT
          path2 := path + ext;

          // 6kabzQg
          if FileExists(path2) then
             // 7dui4cD
             exe_path_s.add(path2);
        end;
      end;
    end;

    // 8swW6Av
    // Uniquify
    exe_path_s := StringListUniq(exe_path_s);

    // 7y3JlnS
    Result := exe_path_s;
  end;

  function Main: integer;
  var
    usage: string;
    prog: string;
    exe_path_s: TStringList;
    i: integer;
  begin
    // 9mlJlKg
    // If not exactly one command argument is given
    if ParamCount &lt;&gt; 1 then
    begin
      // 7rOUXFo
      // Print program usage
      usage :=
        &#39;Usage: aoikwinwhich PROG&#39;#10 +
        #10 +
        &#39;#/ PROG can be either name or path&#39;#10 +
        &#39;aoikwinwhich notepad.exe&#39;#10 +
        &#39;aoikwinwhich C:\Windows\notepad.exe&#39;#10 +
        #10 +
        &#39;#/ PROG can be either absolute or relative&#39;#10 +
        &#39;aoikwinwhich C:\Windows\notepad.exe&#39;#10 +
        &#39;aoikwinwhich Windows\notepad.exe&#39;#10 +
        #10 +
        &#39;#/ PROG can be either with or without extension&#39;#10 +
        &#39;aoikwinwhich notepad.exe&#39;#10 +
        &#39;aoikwinwhich notepad&#39;#10 +
        &#39;aoikwinwhich C:\Windows\notepad.exe&#39;#10 +
        &#39;aoikwinwhich C:\Windows\notepad&#39;;

      Writeln(usage);

      // 3nqHnP7
      exit(1);
    end;

    // 9m5B08H
    // Get executable name or path
    prog := ParamStr(1);

    // 8ulvPXM
    // Find executable paths
    exe_path_s := FindExePaths(prog);

    // 5fWrcaF
    // If has found none
    if exe_path_s.Count = 0 then
    begin
      // 3uswpx0
      exit(2);
    end
    // If has found some
    else
    begin
      // 9xPCWuS
      // Print result
      for i := 0 to exe_path_s.Count - 1 do
        Writeln(exe_path_s[i]);

      // 4s1yY1b
      exit(0);
    end;
  end;

begin
  // 4zKrqsC
  // Program entry
  exitcode := Main;
end.</code></pre><h2 id="aoikwinwhich-perl"><a class="anchor" href="#aoikwinwhich-perl"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Perl</h2><pre><code>#/
use File::Spec;
use List::Util;

#/
sub find_executable {
    #/
    my $prog = $_[0];

    #/ 8f1kRCu
    my $env_var_PATHEXT = $ENV{&#39;PATHEXT&#39;};
    ## can be undef

    #/ 6qhHTHF
    #/ split into a list of extensions
    my @ext_s =
        !defined(env_var_PATHEXT)
        ? ()
        : split(&#39;;&#39;, $env_var_PATHEXT);

    #/ 2pGJrMW
    #/ strip
    s{^\s+|\s+$}{}g for @ext_s;

    #/ 2gqeHHl
    #/ remove empty
    @ext_s = grep {$_ ne &#39;&#39;} @ext_s;

    #/ 2zdGM8W
    #/ convert to lowercase
    $_ = lc for @ext_s;

    #/ 2fT8aRB
    #/ uniquify
    my %seen = ();
    my @ext_s = grep {!$seen{$_}++} @ext_s;

    #/ 4ysaQVN
    my $env_var_PATH = $ENV{&#39;PATH&#39;};
    ## can be undef

    #/ 6mPI0lg
    my @dir_path_s =
        !defined($env_var_PATH)
        ? ()
        : split(&#39;;&#39;, $env_var_PATH);

    #/ 5rT49zI
    #/ insert empty dir path to the beginning
    #/
    #/ Empty dir handles the case that |prog| is a path, either relative or
    #/  absolute. See code 7rO7NIN.
    unshift(@dir_path_s, &#39;&#39;);

    #/ 2klTv20
    #/ uniquify
    my %seen = ();
    my @dir_path_s = grep {!$seen{$_}++} @dir_path_s;

    #/ 6bFwhbv
    my @exe_path_s = ();

    for my $dir_path (@dir_path_s) {
        #/ 7rO7NIN
        #/ synthesize a path with the dir and prog
        my $path = $dir_path eq &quot;&quot; ? $prog :
            File::Spec-&gt;catpath(undef, $dir_path, $prog);

        #/ 6kZa5cq
        #/ assume the path has extension, check if it is an executable
        if (List::Util::any {2 &gt; 1} @ext_s) {
            if (-f $path) {
                push(@exe_path_s, $path);
            }
        }

        #/ 2sJhhEV
        #/ assume the path has no extension
        for my $ext (@ext_s) {
            #/ 6k9X6GP
            #/ synthesize a new path with the path and the executable extension
            my $path_plus_ext = $path . $ext;

            #/ 6kabzQg
            #/ check if it is an executable
            if (-f $path_plus_ext) {
                push(@exe_path_s, $path_plus_ext);
            }
        }
    }

    #/
    return @exe_path_s;
}

sub say {
    print @_, &quot;\n&quot;;
}

sub main() {
    #/ 9mlJlKg
    #/ check if one cmd arg is given
    my $argv_len = $#ARGV + 1;

    if ($argv_len != 1) {
        #/ 7rOUXFo
        #/ print program usage
        say &#39;Usage: aoikwinwhich PROG&#39;;
        say &#39;&#39;;
        say &#39;#/ PROG can be either name or path&#39;;
        say &#39;aoikwinwhich notepad.exe&#39;;
        say &#39;aoikwinwhich C:\Windows\notepad.exe&#39;;
        say &#39;&#39;;
        say &#39;#/ PROG can be either absolute or relative&#39;;
        say &#39;aoikwinwhich C:\Windows\notepad.exe&#39;;
        say &#39;aoikwinwhich Windows\\notepad.exe&#39;;
        say &#39;&#39;;
        say &#39;#/ PROG can be either with or without extension&#39;;
        say &#39;aoikwinwhich notepad.exe&#39;;
        say &#39;aoikwinwhich notepad&#39;;
        say &#39;aoikwinwhich C:\Windows\notepad.exe&#39;;
        say &#39;aoikwinwhich C:\Windows\notepad&#39;;

        #/ 3nqHnP7
        return;
    }

    #/ 9m5B08H
    #/ get name or path of a program from cmd arg
    my $prog = $ARGV[0];

    #/ 8ulvPXM
    #/ find executables
    my @path_s = find_executable($prog);

    #/ 5fWrcaF
    #/ has found none, exit
    if (scalar @path_s == 0) {
        #/ 3uswpx0
        return;
    }

    #/ 9xPCWuS
    #/ has found some, output
    my $txt = join(&quot;\n&quot;, @path_s);

    say $txt;

    #/
    return;
}

#/
unless (caller) {
    main();
}</code></pre><h2 id="aoikwinwhich-php"><a class="anchor" href="#aoikwinwhich-php"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-PHP</h2><pre><code>&lt;?php

#/ define a string |endswith| function
function endsWith($str, $sub) {
    return (substr($str, strlen($str) - strlen($sub)) == $sub);
}

function find_executable($prog) {
    #/ 8f1kRCu
    $env_var_PATHEXT = getenv(&#39;PATHEXT&#39;);
    ## can be False

    #/ 6qhHTHF
    #/ split into a list of extensions
    $ext_s = ($env_var_PATHEXT === False)
        ? []
        : explode(PATH_SEPARATOR, $env_var_PATHEXT);

    #/ 2pGJrMW
    #/ strip
    $ext_s = array_map(function($x) {
        return trim($x);
    }, $ext_s);

    #/ 2gqeHHl
    #/ remove empty
    $ext_s = array_filter($ext_s, function($x) {
        return $x !== &#39;&#39;;
    });

    #/ 2zdGM8W
    #/ convert to lowercase
    $ext_s = array_map(function($x) {
        return strtolower($x);
    }, $ext_s);

    #/ 2fT8aRB
    #/ uniquify
    $ext_s = array_unique($ext_s);

    #/ 4ysaQVN
    $env_var_PATH = getenv(&#39;PATH&#39;);
    ## can be False

    #/ 6mPI0lg
    $dir_path_s = ($env_var_PATH === False)
        ? []
        : explode(PATH_SEPARATOR, $env_var_PATH);

    #/ 5rT49zI
    #/ insert empty dir path to the beginning
    ##
    ## Empty dir handles the case that |prog| is a path, either relative or
    ##  absolute. See code 7rO7NIN.
    array_unshift($dir_path_s, &#39;&#39;);

    #/ 2klTv20
    #/ uniquify
    $dir_path_s = array_unique($dir_path_s);

    #/ 6bFwhbv
    $exe_path_s = Array();

    foreach ($dir_path_s as $dir_path) {
        #/ 7rO7NIN
        #/ synthesize a path with the dir and prog
        if ($dir_path === &#39;&#39;) {
            $path = $prog;
        }
        else {
            $path = implode(DIRECTORY_SEPARATOR, array($dir_path, $prog));
        }

        #/ 6kZa5cq
        ## assume the path has extension, check if it is an executable
        $path_has_ext = array_filter($ext_s, function($ext) use ($path){
            return endsWith($path, $ext);
        }) !== array();

        if ($path_has_ext &amp;&amp; is_file($path)) {
            $exe_path_s[] = $path;
        }

        #/ 2sJhhEV
        ## assume the path has no extension
        foreach ($ext_s as $ext) {
            #/ 6k9X6GP
            #/ synthesize a new path with the path and the executable extension
            $path_plus_ext = $path . $ext;

            #/ 6kabzQg
            #/ check if it is an executable
            if (is_file($path_plus_ext)) {
                $exe_path_s[] = $path_plus_ext;
            }
        }
    }

    #/
    return $exe_path_s;
}

function println($txt) {
    print($txt);
    print(&quot;\n&quot;);
}

function main() {
    #/ 9mlJlKg
    global $argv;

    $arg_s = array_slice($argv, 1);

    if (count($arg_s) != 1) {
        #/ 7rOUXFo
        #/ print program usage
        println(&#39;Usage: aoikwinwhich PROG&#39;);
        println(&#39;&#39;);
        println(&#39;#/ PROG can be either name or path&#39;);
        println(&#39;aoikwinwhich notepad.exe&#39;);
        println(&#39;aoikwinwhich C:\Windows\notepad.exe&#39;);
        println(&#39;&#39;);
        println(&#39;#/ PROG can be either absolute or relative&#39;);
        println(&#39;aoikwinwhich C:\Windows\notepad.exe&#39;);
        println(&#39;aoikwinwhich Windows\notepad.exe&#39;);
        println(&#39;&#39;);
        println(&#39;#/ PROG can be either with or without extension&#39;);
        println(&#39;aoikwinwhich notepad.exe&#39;);
        println(&#39;aoikwinwhich notepad&#39;);
        println(&#39;aoikwinwhich C:\Windows\notepad.exe&#39;);
        println(&#39;aoikwinwhich C:\Windows\notepad&#39;);

        #/ 3nqHnP7
        return;
    }

    #/ 9m5B08H
    #/ get name or path of a program from cmd arg
    $prog = $arg_s[0];

    #/ 8ulvPXM
    #/ find executables
    $path_s = find_executable($prog);

    #/ 5fWrcaF
    #/ has found none, exit
    if (empty($path_s)) {
        #/ 3uswpx0
        return;
    }

    #/ 9xPCWuS
    #/ has found some, output
    $txt = implode(&quot;\n&quot;, $path_s);

    println($txt);

    #/ 4s1yY1b
    return;
}

#/
if (!debug_backtrace())
{
    main();
}
?&gt;</code></pre><h2 id="aoikwinwhich-python"><a class="anchor" href="#aoikwinwhich-python"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Python</h2><pre><code># coding: utf-8

#
import os
import sys


#
def list_uniq(item_s):
    item_s_uniq = []

    for item in item_s:
        if item not in item_s_uniq:
            item_s_uniq.append(item)

    return item_s_uniq

# &quot;exe&quot; means executable, not just paths ending with &quot;.exe&quot;
def find_exe_paths(prog):
    # 8f1kRCu
    env_pathext = os.environ.get(&#39;PATHEXT&#39;, None)

    # 4fpQ2RB
    if not env_pathext:
        # 9dqlPRg
        return []

    # 6qhHTHF
    # Split into a list of extensions
    ext_s = env_pathext.split(os.pathsep)

    # 2pGJrMW
    # Strip
    ext_s = [x.strip() for x in ext_s]

    # 2gqeHHl
    # Remove empty.
    # Must be done after the stripping at 2pGJrMW.
    ext_s = [x for x in ext_s if x != &#39;&#39;]

    # 2zdGM8W
    # Convert to lowercase
    ext_s = [x.lower() for x in ext_s]

    # 2fT8aRB
    # Uniquify
    ext_s = list_uniq(ext_s)

    # 4ysaQVN
    env_path = os.environ.get(&#39;PATH&#39;, None)

    # 5gGwKZL
    if not env_path:
        # 7bVmOKe
        # Go ahead with &quot;dir_path_s&quot; being empty
        dir_path_s = []
    else:
        # 6mPI0lg
        # Split into a list of dir paths
        dir_path_s = env_path.split(os.pathsep)

    # 5rT49zI
    # Insert empty dir path to the beginning.
    #
    # Empty dir handles the case that &quot;prog&quot; is a path, either relative or
    #  absolute. See code 7rO7NIN.
    dir_path_s.insert(0, &#39;&#39;)

    # 2klTv20
    # Uniquify
    dir_path_s = list_uniq(dir_path_s)

    # 9gTU1rI
    # Check if &quot;prog&quot; ends with one of the file extension in &quot;ext_s&quot;.
    #
    # &quot;ext_s&quot; are all in lowercase, ensured at 2zdGM8W.
    prog_lc = prog.lower()

    prog_has_ext = prog_lc.endswith(tuple(ext_s))
    # &quot;endswith&quot; requires tuple, not list.

    # 6bFwhbv
    exe_path_s = []

    for dir_path in dir_path_s:
        # 7rO7NIN
        # Synthesize a path
        if dir_path == &#39;&#39;:
            path = prog
        else:
            path = os.path.join(dir_path, prog)

        # 6kZa5cq
        # If &quot;prog&quot; ends with executable file extension
        if prog_has_ext:
            # 3whKebE
            if os.path.isfile(path):
                # 2ffmxRF
                exe_path_s.append(path)

        # 2sJhhEV
        # Assume user has omitted the file extension
        for ext in ext_s:
            # 6k9X6GP
            # Synthesize a path with one of the file extensions in PATHEXT
            path_2 = path + ext

            # 6kabzQg
            if os.path.isfile(path_2):
                # 7dui4cD
                exe_path_s.append(path_2)

    # 8swW6Av
    # Uniquify
    exe_path_s = list_uniq(exe_path_s)

    # 7y3JlnS
    return exe_path_s

#
def main():
    # 9mlJlKg
    # If not exactly one command argument is given
    if len(sys.argv) != 2:
        # 7rOUXFo
        # Print program usage
        usage = r&quot;&quot;&quot;Usage: aoikwinwhich PROG

#/ PROG can be either name or path
aoikwinwhich notepad.exe
aoikwinwhich C:\Windows\notepad.exe

#/ PROG can be either absolute or relative
aoikwinwhich C:\Windows\notepad.exe
aoikwinwhich Windows\notepad.exe

#/ PROG can be either with or without extension
aoikwinwhich notepad.exe
aoikwinwhich notepad
aoikwinwhich C:\Windows\notepad.exe
aoikwinwhich C:\Windows\notepad&quot;&quot;&quot;

        print(usage)

        # 3nqHnP7
        return 1

    #
    assert len(sys.argv) == 2

    # 9m5B08H
    # Get executable name or path
    prog = sys.argv[1]

    # 8ulvPXM
    # Find executable paths
    exe_path_s = find_exe_paths(prog)

    # 5fWrcaF
    # If has found none
    if not exe_path_s:
        # 3uswpx0
        return 2
    # If has found some
    else:
        # 9xPCWuS
        # Print result
        print(&#39;\n&#39;.join(exe_path_s))

        # 4s1yY1b
        return 0

    #
    assert 0

# 4zKrqsC
# Program entry
if __name__ == &#39;__main__&#39;:
    sys.exit(main())</code></pre><h2 id="aoikwinwhich-ruby"><a class="anchor" href="#aoikwinwhich-ruby"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Ruby</h2><pre><code>#/
def find_executable(prog)
    #/ 8f1kRCu
    env_var_PATHEXT = ENV[&#39;PATHEXT&#39;]
    ## can be nil

    #/ 6qhHTHF
    #/ split into a list of extensions
    ext_s = if env_var_PATHEXT.nil?
    then []
    else env_var_PATHEXT.split(File::PATH_SEPARATOR)
    end

    #/ 2pGJrMW
    #/ strip
    ext_s = ext_s.map{|x| x.strip}

    #/ 2gqeHHl
    #/ remove empty
    ext_s = ext_s.select{|x| not x.empty?}

    #/ 2zdGM8W
    #/ convert to lowercase
    ext_s = ext_s.map{|x| x.downcase}

    #/ 2fT8aRB
    #/ uniquify
    ext_s.uniq!

    #/ 4ysaQVN
    env_var_PATH = ENV[&#39;PATH&#39;]
    ## can be nil

    #/ 6mPI0lg
    dir_path_s = if env_var_PATH.nil?
    then []
    else env_var_PATH.split(File::PATH_SEPARATOR)
    end

    #/ 5rT49zI
    #/ insert empty dir path to the beginning
    ##
    ## Empty dir handles the case that |prog| is a path, either relative or absolute.
    ## See code 7rO7NIN.
    if not dir_path_s.include? &#39;&#39;
        dir_path_s.unshift &#39;&#39;
    end

    #/ 2klTv20
    #/ uniquify
    dir_path_s.uniq!

    #/ 6bFwhbv
    exe_path_s = []

    dir_path_s.each do |dir_path|
        #/ 7rO7NIN
        #/ synthesize a path with the dir and prog
        if dir_path.empty?
            path = prog
        else
            path = File.join(dir_path, prog)
        end

        #/ 6kZa5cq
        ## assume the path has extension, check if it is an executable
        if path.end_with?(*ext_s) and File.file? path
            exe_path_s.push(path)
        end

        #/ 2sJhhEV
        ## assume the path has no extension
        ext_s.each do |ext|
            #/ 6k9X6GP
            #/ synthesize a new path with the path and the executable extension
            path_plus_ext = path + ext

            #/ 6kabzQg
            #/ check if it is an executable
            if File.file? path_plus_ext
                exe_path_s.push(path_plus_ext)
            end
        end
    end

    #/ 8swW6Av
    #/ uniquify
    exe_path_s.uniq!

    #/
    exe_path_s.map!{|x| x.sub(&#39;/&#39;, &quot;\\&quot;)}

    #/
    return exe_path_s
end

def main
    #/ 9mlJlKg
    if ARGV.length != 1
        #/ 7rOUXFo
        #/ print program usage
        puts(&#39;Usage: aoikwinwhich PROG&#39;)
        puts(&#39;&#39;)
        puts(&#39;#/ PROG can be either name or path&#39;)
        puts(&#39;aoikwinwhich notepad.exe&#39;)
        puts(&#39;aoikwinwhich C:\Windows\notepad.exe&#39;)
        puts(&#39;&#39;)
        puts(&#39;#/ PROG can be either absolute or relative&#39;)
        puts(&#39;aoikwinwhich C:\Windows\notepad.exe&#39;)
        puts(&#39;aoikwinwhich Windows\notepad.exe&#39;)
        puts(&#39;&#39;)
        puts(&#39;#/ PROG can be either with or without extension&#39;)
        puts(&#39;aoikwinwhich notepad.exe&#39;)
        puts(&#39;aoikwinwhich notepad&#39;)
        puts(&#39;aoikwinwhich C:\Windows\notepad.exe&#39;)
        puts(&#39;aoikwinwhich C:\Windows\notepad&#39;)

        return
    end

    #/ 9m5B08H
    #/ get name or path of a program from cmd arg
    prog = ARGV[0]

    #/ 8ulvPXM
    #/ find executables
    path_s = find_executable(prog)

    #/ 5fWrcaF
    #/ has found none, exit
    if path_s.empty?
        #/ 3uswpx0
        return
    end

    #/ 9xPCWuS
    #/ has found some, output
    txt = path_s.join(&quot;\n&quot;)

    puts txt

    #/ 4s1yY1b
    return
end

if __FILE__ == $0
    main()
end</code></pre><h2 id="aoikwinwhich-rust"><a class="anchor" href="#aoikwinwhich-rust"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Rust</h2><pre><code>//
use std::ascii::AsciiExt;
use std::env;
use std::fs;
use std::process;

//
fn string_to_str(string: &amp;String) -&gt; &amp;str {
    return &amp;string;
}

//
fn string_to_lower(string: &amp;String) -&gt; String {
    return string.chars().map(|c| c.to_ascii_lowercase()).collect();
}

//
fn path_is_file(path: &amp;String) -&gt; bool {
    return match fs::metadata(path) {
        Err(_) =&gt; false,
        Ok(meta) =&gt; meta.is_file(),
    };
}

//
fn strings_uniq(item_s: &amp;Vec&lt;String&gt;) -&gt; Vec&lt;String&gt; {
    //
    let mut item_s_uniq : Vec&lt;String&gt; = Vec::new();

    //
    for item in item_s.iter() {
        if !item_s_uniq.contains(&amp;item) {
            item_s_uniq.push(item.to_string());
        }
    }

    //
    return item_s_uniq
}

//
fn find_exe_paths(prog: &amp;String) -&gt; Vec&lt;String&gt; {
    // 8f1kRCu
    let env_pathext = match env::var(&quot;PATHEXT&quot;) {
        Ok(v) =&gt; v,
        Err(_) =&gt; &quot;&quot;.to_string(),
    };

    // 4fpQ2RB
    if env_pathext.is_empty() {
        // 9dqlPRg
        return vec![];
    }

    // 6qhHTHF
    // Split into a list of extensions
    let mut ext_s : Vec&lt;String&gt; = env_pathext.split(&quot;;&quot;).map(|x| x.to_string())
        .collect();

    // 2pGJrMW
    // Strip
    ext_s = ext_s.iter().map(|x| x.trim().to_string()).collect();

    // 2gqeHHl
    // Remove empty.
    // Must be done after the stripping at 2pGJrMW.
    ext_s = ext_s.iter().filter(|x| !x.is_empty()).map(|x| x.to_string())
        .collect();

    // 2zdGM8W
    // Convert to lowercase
    ext_s = ext_s.iter().map(|x| string_to_lower(x)).collect();

    // 2fT8aRB
    // Uniquify
    ext_s = strings_uniq(&amp;ext_s);

    // 4ysaQVN
    let env_path = match env::var(&quot;PATH&quot;) {
        Ok(v) =&gt; v,
        Err(_) =&gt; &quot;&quot;.to_string(),
    };

    // 5gGwKZL
    let mut dir_path_s : Vec&lt;String&gt; =
        // 7bVmOKe
        // Go ahead with &quot;dir_path_s&quot; being empty
        if env_path.is_empty() {
            vec![]
        }
        else {
        // 6mPI0lg
        // Split into a list of dir paths
        env_path.split(&quot;;&quot;).map(|x| x.to_string()).collect()
        };

    // 5rT49zI
    // Insert empty dir path to the beginning.
    //
    // Empty dir handles the case that &quot;prog&quot; is a path, either relative or
    //  absolute. See code 7rO7NIN.
    dir_path_s.insert(0, &quot;&quot;.to_string());

    // 2klTv20
    // Uniquify
    dir_path_s = strings_uniq(&amp;dir_path_s);

    // 9gTU1rI
    // Check if &quot;prog&quot; ends with one of the file extension in &quot;ext_s&quot;.
    //
    // &quot;ext_s&quot; are all in lowercase, ensured at 2zdGM8W.
    let prog_lc : &amp;str = &amp; string_to_lower(prog);

    let prog_has_ext = ext_s.iter().find(|ext|
        prog_lc.ends_with(string_to_str(ext))).is_some();

    // 6bFwhbv
    let mut exe_path_s : Vec&lt;String&gt; = Vec::new();

    for dir_path in dir_path_s.iter() {
        // 7rO7NIN
        // Synthesize a path
        let path =
            if dir_path.is_empty() {
                prog.to_owned()
            }
            else {
                format!(&quot;{}\\{}&quot;, dir_path, prog)
            };

        // 6kZa5cq
        // If &quot;prog&quot; ends with executable file extension
        if prog_has_ext {
            // 3whKebE
            if path_is_file(&amp;path) {
                // 2ffmxRF
                exe_path_s.push(path.to_owned());
            }
        }

        // 2sJhhEV
        // Assume user has omitted the file extension
        for ext in ext_s.iter() {
            // 6k9X6GP
            // Synthesize a path with one of the file extensions in PATHEXT
            let path_2 = format!(&quot;{}{}&quot;, path, ext);

            // 6kabzQg
            if path_is_file(&amp;path_2) {
                // 7dui4cD
                exe_path_s.push(path_2);
            }
        }
    }

    // 8swW6Av
    // Uniquify
    exe_path_s = strings_uniq(&amp;exe_path_s);

    // 7y3JlnS
    return exe_path_s;
}

// 4zKrqsC
// Program entry
fn main() {
    //
    let arg_s: Vec&lt;_&gt; = env::args().collect();

    // 9mlJlKg
    // If not exactly one command argument is given
    if arg_s.len() != 2 {
        // 7rOUXFo
        // Print program usage
        let usage = &quot;Usage: aoikwinwhich PROG

#/ PROG can be either name or path
aoikwinwhich notepad.exe
aoikwinwhich C:\\Windows\\notepad.exe

#/ PROG can be either absolute or relative
aoikwinwhich C:\\Windows\\notepad.exe
aoikwinwhich Windows\\notepad.exe

#/ PROG can be either with or without extension
aoikwinwhich notepad.exe
aoikwinwhich notepad
aoikwinwhich C:\\Windows\\notepad.exe
aoikwinwhich C:\\Windows\\notepad&quot;;

        println!(&quot;{}&quot;, usage);

        // 3nqHnP7
        process::exit(1);
    }

    // 9m5B08H
    // Get executable name or path
    let ref prog = arg_s[1];

    // 8ulvPXM
    // Find executable paths
    let ref exe_path_s = find_exe_paths(prog);

    // 5fWrcaF
    // If has found none
    if arg_s.len() == 0 {
        // 3uswpx0
        process::exit(2);
    }
    else {
        // 9xPCWuS
        // Print result
        println!(&quot;{}&quot;, exe_path_s.connect(&quot;\n&quot;));

        // 4s1yY1b
        process::exit(0);
    }
}</code></pre><h2 id="aoikwinwhich-scala"><a class="anchor" href="#aoikwinwhich-scala"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Scala</h2><pre><code>//
package aoikwinwhich
import java.io.File
import java.nio.file.Files
import java.nio.file.Paths
import scala.collection.mutable.ListBuffer

//
object AoikWinWhich {

    def find_executable(prog: String): List[String] = {
        // 8f1kRCu
        val env_var_PATHEXT = System.getenv(&quot;PATHEXT&quot;)
        /// can be null

        // 6qhHTHF
        // split into a list of extensions
        var ext_s =
            if (env_var_PATHEXT == null)
                List[String]()
            else
                env_var_PATHEXT.split(File.pathSeparator).toList

        // 2pGJrMW
        // strip
        ext_s = ext_s.map(_.trim)

        // 2gqeHHl
        // remove empty
        ext_s = ext_s.filter(_ != &quot;&quot;)

        // 2zdGM8W
        // convert to lowercase
        ext_s = ext_s.map(_.toLowerCase)

        // 2fT8aRB
        // uniquify
        ext_s = ext_s.distinct
        /// |distinct| keeps the original order.

        // 4ysaQVN
        val env_var_PATH = System.getenv(&quot;PATH&quot;)
        /// can be null

        // 6mPI0lg
        var dir_path_s =
            if (env_var_PATH == null)
                ListBuffer[String]()
            else
                env_var_PATH.split(File.pathSeparator).to[ListBuffer]

        // 5rT49zI
        // insert empty dir path to the beginning
        //
        // Empty dir handles the case that |prog| is a path, either relative or
        //  absolute. See code 7rO7NIN.
        &quot;&quot; +=: dir_path_s

        // 2klTv20
        // uniquify
        dir_path_s = dir_path_s.distinct
        /// |distinct| keeps the original order.

        // 6bFwhbv
        val exe_path_s = ListBuffer[String]()

        for (dir_path &lt;- dir_path_s) {
            // 7rO7NIN
            // synthesize a path with the dir and prog
            val path =
                if (dir_path == &quot;&quot;)
                    prog
                else
                    Paths.get(dir_path, prog).toString

            // 6kZa5cq
            // assume the path has extension, check if it is an executable
            if (ext_s.exists(path.endsWith _)) {
                if (Files.isRegularFile(Paths.get(path))) {
                    exe_path_s += path
                }
            }

            // 2sJhhEV
            // assume the path has no extension
            for (ext &lt;- ext_s) {
                // 6k9X6GP
                // synthesize a new path with the path and the executable extension
                val path_plus_ext = path + ext

                // 6kabzQg
                // check if it is an executable
                if (Files.isRegularFile(Paths.get(path_plus_ext))) {
                    exe_path_s += path_plus_ext
                }
            }
        }

        //
        return exe_path_s.toList
    }

    def main(args: Array[String]) {
        // 9mlJlKg
        // check if one cmd arg is given
        if (args.length != 1) {
            // 7rOUXFo
            // print program usage
            println(&quot;Usage: aoikwinwhich PROG&quot;)
            println(&quot;&quot;)
            println(&quot;#/ PROG can be either name or path&quot;)
            println(&quot;aoikwinwhich notepad.exe&quot;)
            println(&quot;aoikwinwhich C:\\Windows\\notepad.exe&quot;)
            println(&quot;&quot;)
            println(&quot;#/ PROG can be either absolute or relative&quot;)
            println(&quot;aoikwinwhich C:\\Windows\\notepad.exe&quot;)
            println(&quot;aoikwinwhich Windows\\notepad.exe&quot;)
            println(&quot;&quot;)
            println(&quot;#/ PROG can be either with or without extension&quot;)
            println(&quot;aoikwinwhich notepad.exe&quot;)
            println(&quot;aoikwinwhich notepad&quot;)
            println(&quot;aoikwinwhich C:\\Windows\\notepad.exe&quot;)
            println(&quot;aoikwinwhich C:\\Windows\\notepad&quot;)

            // 3nqHnP7
            return
        }

        // 9m5B08H
        // get name or path of a program from cmd arg
        val prog = args(0)

        // 8ulvPXM
        // find executables
        val path_s = find_executable(prog)

        // 5fWrcaF
        // has found none, exit
        if (path_s.size == 0) {
            // 3uswpx0
            return
        }

        // 9xPCWuS
        // has found some, output
        val txt = path_s.mkString(&quot;\n&quot;)

        println(txt)

        //
        return
    }
}</code></pre><h2 id="aoikwinwhich-scheme"><a class="anchor" href="#aoikwinwhich-scheme"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Scheme</h2><pre><code>;
#lang scheme

;
(define (string-endswith str end)
  (let ([str_len ; be
    (string-length str)
    ]
    [end_len ; be
    (string-length end)
    ])
    ; then
    (if (&lt; str_len end_len)
      ; then
      #f
      ; else
      (equal? end (substring str (- str_len end_len)))
    )
  )
)

;
(define (find_exe_paths prog)
  ; 8f1kRCu
  (let ([env_pathext (getenv &quot;PATHEXT&quot;)])
  ; in

    ; 4fpQ2RB
    (if (not env_pathext)
      ; then
      ; 9dqlPRg
      ; Return
      &#39;()
      ; else
      ; 6qhHTHF
      ; Split into a list of extensions
      (let ([ext_s
        ; be
        (string-split env_pathext &quot;;&quot;)
        ])
        ; in

        ; 2pGJrMW
        ; Strip
        (let ([ext_s
          ; be
          (for/list ([ext ext_s]) (string-trim ext))
          ])
          ; in

          ; 2gqeHHl
          ; Remove empty.
          ; Must be done after the stripping at 2pGJrMW.
          (let ([ext_s
            ; be
            (filter (lambda (x) (not (equal? x &quot;&quot;))) ext_s)
            ])
            ; in

            ; 2zdGM8W
            ; Convert to lowercase
            (let ([ext_s
              ; be
              (for/list ([ext ext_s]) (string-downcase ext))
              ])
              ; in

              ; 2fT8aRB
              ; Uniquify
              (let ([ext_s
                ; be
                (remove-duplicates ext_s)
                ])
                ; in

                ; 4ysaQVN
                (let ([env_path
                  ; be
                  (getenv &quot;PATH&quot;)])
                  ; in

                  ;
                  (let ([dir_path_s
                    ; be
                    ; 5gGwKZL
                    (if (not env_path)
                      ; then
                      &#39;()
                      ; else
                      ; 6mPI0lg
                      ; Split into a list of extensions
                      (string-split env_path &quot;;&quot;)
                    )
                    ])
                    ; in
                    ; 5rT49zI
                    ; Insert empty dir path to the beginning.
                    ;
                    ; Empty dir handles the case that &quot;prog&quot; is a path,
                    ; either relative or absolute. See code 7rO7NIN.
                    (let ([dir_path_s
                      ; be
                      (cons &quot;&quot; dir_path_s)
                      ])
                      ; in

                      ; 2klTv20
                      ; Uniquify
                      (let ([dir_path_s
                        ; be
                        (remove-duplicates dir_path_s)
                        ])
                        ; in

                        ; 9gTU1rI
                        ; Check if &quot;prog&quot; ends with one of the file
                        ; extension in &quot;ext_s&quot;.
                        ;
                        ; &quot;ext_s&quot; are all in lowercase, ensured at 2zdGM8W.
                        (let ([prog_lc
                          ; be
                          (string-downcase prog)
                          ])
                          ; in
                          (let ([prog_has_ext
                            ; be
                            (findf (lambda (ext) (string-endswith prog_lc ext))
                              ext_s)
                            ])
                            ; in

                            ; 6bFwhbv
                            (let ([exe_path_s
                              ; be
                              &#39;()
                              ])
                              ; in
                              (begin
                                (for ([dir_path dir_path_s])
                                  ; 7rO7NIN
                                  ; Synthesize a path
                                  (let ([path ; be
                                    (if (equal? dir_path &quot;&quot;)
                                        ; then
                                        prog
                                        ;else
                                        (string-join
                                          (list dir_path &quot;\\&quot; prog) &quot;&quot;
                                        )
                                    )
                                    ])
                                    ; in
                                    (begin
                                      ; 6kZa5cq
                                      ; If &quot;prog&quot; ends with executable file
                                      ; extension
                                      (if prog_has_ext
                                          ; then
                                          ; 3whKebE
                                          (if (file-exists? path)
                                            ; then
                                            ; 2ffmxRF
                                            ; Use &quot;cons&quot; so remember to
                                            ; reverse at 2qScrZs
                                            (set! exe_path_s
                                              (cons path exe_path_s)
                                            )
                                            ; else
                                            #f
                                            )
                                          ; else
                                          #f
                                          )

                                      ; 2sJhhEV
                                      ; Assume user has omitted the file
                                      ; extension
                                      (for ([ext ext_s])
                                        ; 6k9X6GP
                                        ; Synthesize a path with one of the
                                        ; file extensions in PATHEXT
                                        (let ([path
                                          ; be
                                          (string-append path ext)
                                          ])
                                          ; in

                                          ; 6kabzQg
                                          (if (file-exists? path)
                                              ; then
                                              ; 7dui4cD
                                              (set! exe_path_s (cons path exe_path_s))
                                              ; Use &quot;cons&quot; so remember to
                                              ; reverse at 2qScrZs

                                              ; else
                                              #f
                                              )
                                          )
                                        )
                                      )
                                    )
                                  )

                                ; Reverse due to &quot;cons&quot; at 2ffmxRF and
                                ; 7dui4cD
                                (let ([exe_path_s
                                  ; be
                                  (reverse exe_path_s)
                                  ])
                                  ; in

                                  ; 8swW6Av
                                  ; Uniquify
                                  (let ([exe_path_s
                                    ; be
                                    (remove-duplicates exe_path_s)
                                    ])
                                    ; in

                                    ; 2qScrZs
                                    ; Return
                                    exe_path_s
                                  )
                                )
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
)

;
(define (main)
  ;
  (let ([cmd_len ; be
         (vector-length (current-command-line-arguments))
         ])

    ; 9mlJlKg
    ; If not exactly one command argument is given
    (if (not (equal? cmd_len 1))
        ; then
        (begin
          ; 7rOUXFo
          ; Print program usage
          (printf &quot;Usage: aoikwinwhich PROG

#/ PROG can be either name or path
aoikwinwhich notepad.exe
aoikwinwhich C:\\Windows\\notepad.exe

#/ PROG can be either absolute or relative
aoikwinwhich C:\\Windows\\notepad.exe
aoikwinwhich Windows\\notepad.exe

#/ PROG can be either with or without extension
aoikwinwhich notepad.exe
aoikwinwhich notepad
aoikwinwhich C:\\Windows\\notepad.exe
aoikwinwhich C:\\Windows\\notepad
&quot;)

          ; 3nqHnP7
          ; Exit
          1
          )
        ; else
        ; 9m5B08H
        ; Get executable name or path
        (let ([prog ; be
               (vector-ref (current-command-line-arguments) 0)
               ])
          ; then
          ; 8ulvPXM
          ; Find executable paths
          (let ([exe_path_s ; be
                 (find_exe_paths prog)
                 ])
            ; 5fWrcaF
            ; Has found none
            (if (empty? exe_path_s)
                ; then
                ; 3uswpx0
                ; Exit
                2
                ; else
                (begin
                  ; 9xPCWuS
                  ; Print result
                  (printf (string-append (string-join exe_path_s &quot;\n&quot;) &quot;\n&quot;))

                  ; 4s1yY1b
                  ; Exit
                  0
                  )
                )
            )
          )
        )
    )
  )

; 4zKrqsC
; Program entry
(exit (main))</code></pre><h2 id="aoikwinwhich-tcl"><a class="anchor" href="#aoikwinwhich-tcl"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Tcl</h2><pre><code>#/

proc ret {x} {
    return $x
}

#/ Modified from |http://stackoverflow.com/a/3235303|
##
## This proc returns a func-like list with |apply| being first item, and
##  |apply|&#39;s first arg (i.e. func definition) as second item.
## When the result list is expanded using syntax |{*}$f|, |apply| becomes the
##  command, it will perform the func call. Any following args become args of
##  the func call.
##
## Syntax for creating a func-like list:
## &#39;&#39;&#39;
## set fl [func {x} {expr $x &gt; 0}]
## &#39;&#39;&#39;
##
## Syntax for calling a func-like list:
## &#39;&#39;&#39;
## {*}$fl $arg
## &#39;&#39;&#39;
proc func {args body} {
    set ns [uplevel 1 namespace current]
    return [list ::apply [list $args $body $ns]]
}

proc any {item_s funcl} {
    foreach item $item_s {
        if {[{*}$funcl $item] != 0} {
            return 1
        }
    }
    return 0
}

#/ Modified from |http://stackoverflow.com/a/20376860|
proc uniq item_s {
    set item_d [dict create]

    foreach item $item_s {
        dict set item_d $item 1
    }

    return [dict keys $item_d]
}

proc endswith {hay ndl} {
    set hay_len [string length $hay]

    set ndl_len [string length $ndl]

    if {[expr $hay_len &lt; $ndl_len]} {
        return 0
    } else {
        if {[expr [string last $ndl $hay] == [expr $hay_len - $ndl_len]]} {
            return 1
        } else {
            return 0
        }
    }
}

proc find_executable prog {
    #/ 8f1kRCu
    set env_var_PATHEXT [
        if {[info exists ::env(PATHEXT)]} {
            ret $::env(PATHEXT)
        } else {
            ret {}
        }
    ]

    #/ 6qhHTHF
    #/ split into a list of extensions
    set ext_s [
        if {[string length $env_var_PATHEXT] == 0} {
            ret [list]
        } else {
            ret [split $env_var_PATHEXT &quot;;&quot;]
        }
    ]

    #/ 2pGJrMW
    #/ strip
    set ext_s [lmap x $ext_s {set x [string trim $x]}]

    #/ 2gqeHHl
    #/ remove empty
    set ext_s [lmap x $ext_s {
        if {[string length $x] == 0} continue
        set x
        }
    ]

    #/ 2zdGM8W
    #/ convert to lowercase
    set ext_s [lmap x $ext_s {set x [string tolower $x]}]

    #/ 2fT8aRB
    #/ uniquify
    set ext_s [uniq $ext_s]

    #/ 4ysaQVN
    set env_var_PATH [
        if {[info exists ::env(PATH)]} {
            ret $::env(PATH)
        } else {
            ret {}
        }
    ]

    #/ 6mPI0lg
    set dir_path_s [
        if {[string length $env_var_PATH] == 0} {
            ret [list]
        } else {
            ret [split $env_var_PATH &quot;;&quot;]
        }
    ]

    #/ 5rT49zI
    #/ insert empty dir path to the beginning
    ##
    ## Empty dir handles the case that |prog| is a path, either relative or
    ##  absolute. See code 7rO7NIN.
    set dir_path_s [linsert $dir_path_s 0 &quot;&quot;]

    #/ 2klTv20
    #/ uniquify
    set dir_path_s [uniq $dir_path_s]

    #/
    set prog_lc [string tolower $prog]

    set func_body &quot;endswith $prog_lc \$ext&quot;
    ## Must substitute |$prog_lc| to its value here
    ##  because |func| below does not support closure.

    set prog_has_ext [any $ext_s [func {ext} $func_body]]

    #/ 6bFwhbv
    set exe_path_s [list]

    foreach dir_path $dir_path_s {
        #/ 7rO7NIN
        #/ synthesize a path with the dir and prog
        set path [
            if {$dir_path == &quot;&quot;} {
                ret $prog
            } else {
                ret [string cat $dir_path [file separator] $prog]
            }
        ]

        #/ 6kZa5cq
        ## assume the path has extension, check if it is an executable
        if {$prog_has_ext &amp;&amp; [file isfile $path]} {
            set exe_path_s [lappend exe_path_s $path]
        }

        #/ 2sJhhEV
        ## assume the path has no extension
        foreach ext $ext_s {
            #/ 6k9X6GP
            #/ synthesize a new path with the path and the executable extension
            set path_plus_ext [string cat $path $ext]

            #/ 6kabzQg
            #/ check if it is an executable
            if {[file isfile $path_plus_ext]} {
                set exe_path_s [lappend exe_path_s $path_plus_ext]
            }
        }
    }

    #/ 8swW6Av
    #/ uniquify
    set exe_path_s [uniq $exe_path_s]

    #/
    return $exe_path_s
}

proc main {} {
    #/ 9mlJlKg
    if {[llength $::argv] != 1} {
        #/ 7rOUXFo
        #/ print program usage
        puts {Usage: aoikwinwhich PROG}
        puts {}
        puts {#/ PROG can be either name or path}
        puts {aoikwinwhich notepad.exe}
        puts {aoikwinwhich C:\Windows\notepad.exe}
        puts {}
        puts {#/ PROG can be either absolute or relative}
        puts {aoikwinwhich C:\Windows\notepad.exe}
        puts {aoikwinwhich Windows\notepad.exe}
        puts {}
        puts {#/ PROG can be either with or without extension}
        puts {aoikwinwhich notepad.exe}
        puts {aoikwinwhich notepad}
        puts {aoikwinwhich C:\Windows\notepad.exe}
        puts {aoikwinwhich C:\Windows\notepad}

        #/ 3nqHnP7
        return
    }

    #/ 9m5B08H
    #/ get name or path of a program from cmd arg
    set prog [lindex $::argv 0]

    #/ 8ulvPXM
    #/ find executables
    set path_s [find_executable $prog]

    #/ 5fWrcaF
    #/ has found none, exit
    if {[llength $path_s] == 0} {
        #/ 3uswpx0
        return
    }

    #/ 9xPCWuS
    #/ has found some, output
    set txt [join $path_s &quot;\n&quot;]

    puts $txt

    #/ 4s1yY1b
    return
}

main</code></pre><h2 id="aoikwinwhich-vb-net"><a class="anchor" href="#aoikwinwhich-vb-net"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-VB.NET</h2><pre><code>&#39;&#39;
Imports System.IO

&#39;&#39;
Module AoikWinWhich

    Function find_executable(ByVal prog As String) As List(Of String)
        &#39;&#39; 8f1kRCu
        Dim env_var_PATHEXT = Environment.GetEnvironmentVariable(&quot;PATHEXT&quot;)
        &#39;&#39;# can be Nothing

        &#39;&#39; 6qhHTHF
        &#39;&#39; split into a list of extensions
        Dim ext_s = If(env_var_PATHEXT = Nothing,
                New List(Of String)(),
                New List(Of String)(env_var_PATHEXT.Split(Path.PathSeparator))
        )

        &#39;&#39; 2pGJrMW
        &#39;&#39; strip
        ext_s = ext_s.Select(Function(x) x.Trim()).ToList()

        &#39;&#39; 2gqeHHl
        &#39;&#39; remove empty
        ext_s = ext_s.Where(Function(x) x &lt;&gt; &quot;&quot;).ToList()

        &#39;&#39; 2zdGM8W
        &#39;&#39; convert to lowercase
        ext_s = ext_s.Select(Function(x) x.ToLower()).ToList()

        &#39;&#39; 2fT8aRB
        &#39;&#39; uniquify
        ext_s = ext_s.Distinct().ToList()

        &#39;&#39; 4ysaQVN
        Dim env_var_PATH = Environment.GetEnvironmentVariable(&quot;PATH&quot;)
        &#39;&#39;# can be Nothing

        Dim dir_path_s = If(env_var_PATH = Nothing,
                New List(Of String)(),
                New List(Of String)(env_var_PATH.Split(Path.PathSeparator))
        )

        &#39;&#39; 5rT49zI
        &#39;&#39; insert empty dir path to the beginning
        &#39;&#39;
        &#39;&#39; Empty dir handles the case that |prog| is a path, either relative or
        &#39;&#39;  absolute. See code 7rO7NIN.
        dir_path_s.Insert(0, &quot;&quot;)

        &#39;&#39; 2klTv20
        &#39;&#39; uniquify
        dir_path_s = dir_path_s.Distinct().ToList()

        &#39;&#39;
        Dim prog_lc = prog.ToLower()

        Dim prog_has_ext = ext_s.Any(Function(ext) prog_lc.EndsWith(ext))

        &#39;&#39; 6bFwhbv
        Dim exe_path_s = New List(Of String)

        For Each dir_path In dir_path_s
            &#39;&#39; 7rO7NIN
            &#39;&#39; synthesize a path with the dir and prog
            Dim file_path = If(dir_path = &quot;&quot;,
                    prog,
                    Path.Combine(dir_path, prog)
            )

            &#39;&#39; 6kZa5cq
            &#39;&#39; assume the path has extension, check if it is an executable
            If prog_has_ext And File.Exists(file_path) Then
                exe_path_s.Add(file_path)
            End If

            &#39;&#39; 2sJhhEV
            &#39;&#39; assume the path has no extension
            For Each ext In ext_s
                &#39;&#39; 6k9X6GP
                &#39;&#39; synthesize a new path with the path and the executable extension
                Dim path_plus_ext = file_path + ext

                &#39;&#39; 6kabzQg
                &#39;&#39; check if it is an executable
                If File.Exists(path_plus_ext) Then
                    exe_path_s.Add(path_plus_ext)
                End If
            Next
        Next

        &#39;&#39; 8swW6Av
        &#39;&#39; uniquify
        exe_path_s = exe_path_s.Distinct().ToList()

        &#39;&#39;
        Return exe_path_s
    End Function

    Sub Main()
        &#39;&#39; 9mlJlKg
        Dim args = Environment.GetCommandLineArgs()
        &#39;&#39;# first arg is this program&#39;s path.

        If args.Length &lt;&gt; 2 Then
            &#39;&#39; 7rOUXFo
            &#39;&#39; print program usage
            Console.WriteLine(&quot;Usage: aoikwinwhich PROG&quot;)
            Console.WriteLine(&quot;&quot;)
            Console.WriteLine(&quot;#/ PROG can be either name or path&quot;)
            Console.WriteLine(&quot;aoikwinwhich notepad.exe&quot;)
            Console.WriteLine(&quot;aoikwinwhich C:\Windows\notepad.exe&quot;)
            Console.WriteLine(&quot;&quot;)
            Console.WriteLine(&quot;#/ PROG can be either absolute or relative&quot;)
            Console.WriteLine(&quot;aoikwinwhich C:\Windows\notepad.exe&quot;)
            Console.WriteLine(&quot;aoikwinwhich Windows\notepad.exe&quot;)
            Console.WriteLine(&quot;&quot;)
            Console.WriteLine(&quot;#/ PROG can be either with or without extension&quot;)
            Console.WriteLine(&quot;aoikwinwhich notepad.exe&quot;)
            Console.WriteLine(&quot;aoikwinwhich notepad&quot;)
            Console.WriteLine(&quot;aoikwinwhich C:\Windows\notepad.exe&quot;)
            Console.WriteLine(&quot;aoikwinwhich C:\Windows\notepad&quot;)

            &#39;&#39; 3nqHnP7
            Return
        End If

        &#39;&#39; 9m5B08H
        &#39;&#39; get name or path of a program from cmd arg
        Dim prog = args(1)

        &#39;&#39; 8ulvPXM
        &#39;&#39; find executables
        Dim path_s = find_executable(prog)

        &#39;&#39; 5fWrcaF
        &#39;&#39; has found none, exit
        If path_s.Count = 0 Then
            &#39;&#39; 3uswpx0
            Return
        End If

        &#39;&#39; 9xPCWuS
        &#39;&#39; has found some, output
        Dim txt = String.Join(Environment.NewLine, path_s)

        Console.WriteLine(txt)

        &#39;&#39; 4s1yY1b
        Return
    End Sub

End Module</code></pre><h2 id="aoikwinwhich-xtend"><a class="anchor" href="#aoikwinwhich-xtend"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg> </a>AoikWinWhich-Xtend</h2><pre><code>//
package aoikwinwhich

import java.io.File
import java.nio.file.Files
import java.nio.file.Paths
import java.util.Arrays
import java.util.LinkedHashSet
import java.util.LinkedList
import java.util.List

//
class AoikWinWhich {

    def static List&lt;String&gt; find_executable(String prog) {
        // 8f1kRCu
        val env_var_PATHEXT = System.getenv(&quot;PATHEXT&quot;)
        /// can be null

        // 6qhHTHF
        // split into a list of extensions
        var ext_s =
            if (env_var_PATHEXT == null)
                newLinkedList
            else
                Arrays.asList(env_var_PATHEXT.split(File.pathSeparator))

        // 2pGJrMW
        // strip
        ext_s = ext_s.map[ x | x.trim() ].toList()

        // 2gqeHHl
        // remove empty
        ext_s = ext_s.filter[ x | x != &quot;&quot; ].toList()

        // 2zdGM8W
        // convert to lowercase
        ext_s = ext_s.map[ x | x.toLowerCase() ].toList()

        // 2fT8aRB
        // uniquify
        ext_s = new LinkedList(new LinkedHashSet(ext_s))
        /// LinkedHashSet keeps the original order.

        // 4ysaQVN
        val env_var_PATH = System.getenv(&quot;PATH&quot;)
        /// can be null

        // 6mPI0lg
        var dir_path_s =
            if (env_var_PATH == null)
                newLinkedList
            else
                new LinkedList(Arrays.asList(env_var_PATH.split(File.pathSeparator)))

        // 5rT49zI
        // insert empty dir path to the beginning
        //
        // Empty dir handles the case that |prog| is a path, either relative or
        //  absolute. See code 7rO7NIN.
        dir_path_s.add(0, &quot;&quot;)

        // 2klTv20
        // uniquify
        dir_path_s = new LinkedList(new LinkedHashSet(dir_path_s))
        /// LinkedHashSet keeps the original order.

        //
        val prog_lc = prog.toLowerCase()

        val prog_has_ext = ext_s.exists[ ext | prog_lc.endsWith(ext) ]

        // 6bFwhbv
        var exe_path_s = new LinkedList&lt;String&gt;()

        for (String dir_path : dir_path_s) {
            // 7rO7NIN
            // synthesize a path with the dir and prog
            val path =
                if (dir_path == &quot;&quot;)
                    prog
                else
                    Paths.get(dir_path, prog).toString()

            // 6kZa5cq
            // assume the path has extension, check if it is an executable
            if (prog_has_ext &amp;&amp; Files.isRegularFile(Paths.get(path))) {
                 exe_path_s.add(path)
            }

            // 2sJhhEV
            // assume the path has no extension
            for (String ext : ext_s) {
                // 6k9X6GP
                // synthesize a new path with the path and the executable extension
                val path_plus_ext = path + ext

                // 6kabzQg
                // check if it is an executable
                if (Files.isRegularFile(Paths.get(path_plus_ext))) {
                    exe_path_s.add(path_plus_ext)
                }
            }
        }

        // 8swW6Av
        // uniquify
        exe_path_s = new LinkedList(new LinkedHashSet(exe_path_s))
        /// LinkedHashSet keeps the original order.

        //
        return exe_path_s
    }

    def static void main(String[] args) {
        // 9mlJlKg
        // check if one cmd arg is given
        if (args.length != 1) {
            // 7rOUXFo
            // print program usage
            println(&#39;Usage: aoikwinwhich PROG&#39;)
            println(&#39;&#39;)
            println(&#39;#/ PROG can be either name or path&#39;)
            println(&#39;aoikwinwhich notepad.exe&#39;)
            println(&#39;aoikwinwhich C:\\Windows\\notepad.exe&#39;)
            println(&#39;&#39;)
            println(&#39;#/ PROG can be either absolute or relative&#39;)
            println(&#39;aoikwinwhich C:\\Windows\\notepad.exe&#39;)
            println(&#39;aoikwinwhich Windows\\notepad.exe&#39;)
            println(&#39;&#39;)
            println(&#39;#/ PROG can be either with or without extension&#39;)
            println(&#39;aoikwinwhich notepad.exe&#39;)
            println(&#39;aoikwinwhich notepad&#39;)
            println(&#39;aoikwinwhich C:\\Windows\\notepad.exe&#39;)
            println(&#39;aoikwinwhich C:\\Windows\\notepad&#39;)

            // 3nqHnP7
            return
        }

        // 9m5B08H
        // get name or path of a program from cmd arg
        val prog = args.get(0)

        // 8ulvPXM
        // find executables
        val path_s = find_executable(prog)

        // 5fWrcaF
        // has found none, exit
        if (path_s.size() == 0) {
            // 3uswpx0
            return
        }

        // 9xPCWuS
        // has found some, output
        val txt = String.join(&quot;\n&quot;, path_s)

        println(txt)

        // 4s1yY1b
        return
    }
}</code></pre>
  </article>
  <!-- post_content -->

  <div class="prev_next_posts_block">
    <div>
      <span class="prev_post_prompt">Last Post: </span><a class="prev_post_link" href="/blog/posts/python-class-method-closure">Python class method closure</a><span class="prev_post_date">(2019.10.29)</span>
    </div>
    <div>
      <span class="next_post_prompt">Next Post: </span><a class="next_post_link" href="/blog/posts/c-how-variable-length-array-is-implemented">C how variable length array is implemented</a><span class="next_post_date">(2018.09.19)</span>
    </div>
  </div>

  <!-- Special syntax below is for Vue rendering on the client side -->
  <div v-cloak id="post_comments_block" class="post_comments_block">
    <p class="title">Comments:</p>
    <div class="write_comment_block">
      <div class="comment_info_block">
        <input v-model="commenter_name" class="commenter_name" placeholder="Your name"></input>
        <div class="replyto_block">
          <span>Reply to:</span>
          <select v-model="replyto_comment_id">
             <!-- `0` is a special value meaning no replyto -->
             <option disabled value="0"></option>
             <option v-for="comment_id in comment_ids" :value="comment_id">{{comment_id}}</option>
          </select>
        </div>
      </div>
      <textarea v-model="comment_content" class="comment_content" placeholder="Comment"></textarea>
      <div><input v-on:click="comment_submit_button_on_click" class="submit_button" type="button" value="Submit"></input></div>
    </div>
    <ul>
        <li v-for="comment_info in comment_infos" v-bind:class="comment_info.is_admin ? 'is_admin' : ''">
            <a v-bind:id="'comment-' + comment_info.comment_id"
              v-bind:href="'#comment-' + comment_info.comment_id" class="comment_id">{{comment_info.comment_id}}</a>
            <div class="comment_content">{{comment_info.comment_content}}</div>
            <div class="comment_info">
              <span class="commenter_name">{{comment_info.commenter_name}}</span>
              <span class="create_time">{{comment_info.create_time}}</span>
              <template v-if="comment_info.replyto_comment_id > 0">
              <span>to <a v-bind:href="'#comment-' + comment_info.replyto_comment_id">comment-{{comment_info.replyto_comment_id}}</a></span>
              </template>
              <a v-bind:data-comment-id="comment_info.comment_id" v-on:click="comment_reply_button_on_click" class="reply_button" href="#post_comments_block">Reply to this</a>
            </div>
        </li>
    </ul>
  </div>
  

  <!-- post_toc -->
  <div id="post_toc_block" class="post_toc_block is_hidden">
    <a v-on:click="post_toc_hide_link_on_click" data-shown-text="Hide" data-hidden-text="TOC" class="hide_link" href="javascript:void(0)">TOC</a>
    <span class="title">Contents</span>
  </div>
  <!-- post_toc -->

  <!-- back_to_top -->
  <div id="back_to_top_block" class="back_to_top_block is_hidden">
    <a v-on:click="back_to_top_button_on_click">
      <div class="arrow_shape">
        <div class="arrow_head"></div>
        <div class="arrow_body"></div>
      </div>
    </a>
  </div>
  <!-- back_to_top -->

  <div id="post_id" style="display: none;">1</div>
  <!-- main_inner -->
</main>
<!-- main -->

<!-- back_to_top -->

<!-- footer -->
<footer>
  <!-- footer_inner -->
  <span>This blog is powered by my own project <a href="https://github.com/AoiKuiyuyou/AoikSeldomStaticSite">AoikSeldomStaticSite</a>.</span>
  <!-- footer_inner -->
</footer>
<!-- footer -->

<!-- bottom_scripts -->

<script type="text/javascript" src="/blog/libs_outer/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="/blog/libs_outer/vue/2.5.16/vue.min.js"></script>
<script type="text/javascript" src="/blog/libs_outer/toastr/2.1.3/toastr.min.js"></script>
<script type="text/javascript" src="/blog/libs_outer/highlight/9.12.0/highlight.min.js"></script>
<script type="text/javascript" src="/blog/libs_inner/base/post.js"></script>
<!-- bottom_scripts -->

</div>
<!-- vue_app -->

</body>
</html>
